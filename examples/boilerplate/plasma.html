<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Plasma - Boilerplate</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 16px;
      border-radius: 6px;
      z-index: 100;
      pointer-events: none;
    }

    .info code {
      color: #3b82f6;
    }
  </style>
<link rel="stylesheet" href="../common.css">
<script type="module" src="/examples/code-viewer.js"></script>
</head>

<body>
  <div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Plasma | Move mouse to interact</div>
  <canvas id="canvas"></canvas>
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VANILLA WEBGL2 PLASMA - BOILERPLATE EXAMPLE
    // procedural one-shader effect (matches glsl/plasma.html logic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
      throw new Error('WebGL2 not supported');
    }

    const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

    const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;

// Better color palette function
vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
  return a + b * cos(6.28318 * (c * t + d));
}

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 p = (gl_FragCoord.xy - uResolution * 0.5) / uResolution.y;
  
  float t = uTime * 0.3;
  
  // Mouse influence
  vec2 mouseP = (uMouse - 0.5) * vec2(uResolution.x / uResolution.y, 1.0);
  vec2 m = (uMouse - 0.5);
  m.x *= uResolution.x / uResolution.y;
  
  float mouseDist = length(p - m);
  float mouseInfluence = exp(-mouseDist * 4.0);
  
  // Multiple wave patterns
  float v = 0.0;
  
  // Basic plasma waves
  v += sin(p.x * 10.0 + t * 1.5);
  v += sin(p.y * 10.0 + t * 1.2);
  v += sin((p.x + p.y) * 10.0 + t);
  
  // Circular waves
  float cx = p.x + 0.5 * sin(t * 0.5);
  float cy = p.y + 0.5 * cos(t * 0.4);
  v += sin(sqrt(cx * cx + cy * cy + 1.0) * 12.0 - t * 2.0);
  
  // Additional moving centers
  for (int i = 0; i < 4; i++) {
    float fi = float(i);
    float angle = t * 0.3 + fi * 1.57;
    vec2 center = vec2(cos(angle), sin(angle * 0.7)) * 0.4;
    float d = length(p - center);
    v += sin(d * 15.0 - t * 2.5 + fi);
  }
  
  // Mouse ripple
  v += sin(mouseDist * 30.0 - t * 8.0) * mouseInfluence * 2.0;
  
  v *= 0.15;
  
  // Create multiple color layers
  vec3 col1 = palette(v + t * 0.1, 
    vec3(0.5, 0.5, 0.5), 
    vec3(0.5, 0.5, 0.5), 
    vec3(1.0, 1.0, 1.0), 
    vec3(0.0, 0.33, 0.67)
  );
  
  vec3 col2 = palette(v * 0.7 - t * 0.15,
    vec3(0.5, 0.5, 0.5),
    vec3(0.5, 0.5, 0.5),
    vec3(1.0, 0.7, 0.4),
    vec3(0.0, 0.15, 0.2)
  );
  
  vec3 col3 = palette(v * 0.5 + t * 0.2,
    vec3(0.8, 0.5, 0.4),
    vec3(0.2, 0.4, 0.2),
    vec3(2.0, 1.0, 1.0),
    vec3(0.0, 0.25, 0.25)
  );
  
  // Blend colors
  float blend1 = sin(v * 3.14159) * 0.5 + 0.5;
  float blend2 = cos(v * 2.0 + t) * 0.5 + 0.5;
  
  vec3 color = mix(col1, col2, blend1);
  color = mix(color, col3, blend2 * 0.4);
  
  // Add glow near mouse
  color += vec3(0.4, 0.3, 0.6) * mouseInfluence * 0.6;
  
  // Add pulsing brightness
  float pulse = sin(t * 2.0) * 0.1 + 0.9;
  color *= pulse;
  
  // Enhance contrast
  color = pow(color, vec3(0.85));
  
  // Subtle vignette
  float vignette = 1.0 - length(uv - 0.5) * 0.35;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(vertSource, fragSource) {
      const vs = createShader(gl.VERTEX_SHADER, vertSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(vertexShaderSource, fragmentShaderSource);

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    let mouse = [0.5, 0.5];

    canvas.addEventListener('mousemove', e => {
      mouse[0] = e.clientX / window.innerWidth;
      mouse[1] = 1.0 - e.clientY / window.innerHeight;
    });
    canvas.addEventListener('touchmove', e => {
      if (e.touches.length > 0) {
        mouse[0] = e.touches[0].clientX / window.innerWidth;
        mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
      }
    }, { passive: true });

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    function render(time) {
      time *= 0.001;

      gl.useProgram(program);
      gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time);
      gl.uniform2f(gl.getUniformLocation(program, 'uMouse'), mouse[0], mouse[1]);

      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // FPS Counter
    (function () {
      const fpsDiv = document.createElement('div');
      fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
      document.body.appendChild(fpsDiv);
      let frames = 0, lastTime = performance.now();
      function updateFPS() {
        frames++;
        const now = performance.now();
        if (now - lastTime >= 500) {
          fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
          frames = 0; lastTime = now;
        }
        requestAnimationFrame(updateFPS);
      }
      updateFPS();
    })();

    console.log('%c ğŸŒˆ Vanilla WebGL2 Plasma ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
  </script>
</body>

</html>