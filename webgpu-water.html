<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>gpu() â€” WebGPU Water Simulation</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// gpu() â€” WebGPU Real-time Water Simulation
// Move mouse to create ripples!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const gpu = async (computeCode, renderCode) => {
  if (!navigator.gpu) {
    document.body.innerHTML = `
      <div style="color:#fff;font-family:system-ui;padding:40px;text-align:center">
        <h1>WebGPU Not Supported</h1>
        <p>Use Chrome 129+ or Edge with WebGPU enabled.</p>
        <p>Try the WebGL version: <a href="water.html" style="color:#0af">water.html</a></p>
      </div>`;
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();

  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  canvas.style.cssText = 'position:fixed;inset:0;width:100%;height:100%';

  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();

  let width, height;

  const resize = () => {
    const d = devicePixelRatio * 0.5;
    width = Math.floor(innerWidth * d);
    height = Math.floor(innerHeight * d);
    canvas.width = width;
    canvas.height = height;
    context.configure({ device, format, alphaMode: 'premultiplied' });
  };
  resize();
  addEventListener('resize', resize);

  const mouse = [0, 0, 0, 0];
  let mouseDown = false;
  addEventListener('mousemove', e => {
    mouse[2] = mouse[0];
    mouse[3] = mouse[1];
    mouse[0] = e.clientX / innerWidth;
    mouse[1] = e.clientY / innerHeight;
  });
  addEventListener('mousedown', () => mouseDown = true);
  addEventListener('mouseup', () => mouseDown = false);

  const createStateTexture = () => device.createTexture({
    size: [width, height],
    format: 'rgba16float',
    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
  });

  let stateA = createStateTexture();
  let stateB = createStateTexture();

  const uniformBuffer = device.createBuffer({
    size: 48,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  const computeModule = device.createShaderModule({
    code: /* wgsl */`
      struct Uniforms {
        time: f32,
        mouseX: f32,
        mouseY: f32,
        mouseDown: f32,
        prevMouseX: f32,
        prevMouseY: f32,
        width: f32,
        height: f32,
      }
      
      @group(0) @binding(0) var<uniform> u: Uniforms;
      @group(0) @binding(1) var src: texture_storage_2d<rgba16float, read>;
      @group(0) @binding(2) var dst: texture_storage_2d<rgba16float, write>;

      fn sample(c: vec2<i32>) -> vec4<f32> {
        let dims = vec2<i32>(textureDimensions(src));
        let p = clamp(c, vec2<i32>(0), dims - vec2<i32>(1));
        return textureLoad(src, p);
      }

      ${computeCode}

      @compute @workgroup_size(16, 16)
      fn main(@builtin(global_invocation_id) id: vec3<u32>) {
        let C = vec2<i32>(id.xy);
        let dims = textureDimensions(src);
        if (u32(C.x) >= dims.x || u32(C.y) >= dims.y) { return; }
        let uv = vec2<f32>(C) / vec2<f32>(dims);
        compute(C, uv);
      }
    `
  });

  const computeBindGroupLayout = device.createBindGroupLayout({
    entries: [
      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
      { binding: 1, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: 'read-only', format: 'rgba16float' } },
      { binding: 2, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: 'write-only', format: 'rgba16float' } }
    ]
  });

  const computePipeline = device.createComputePipeline({
    layout: device.createPipelineLayout({ bindGroupLayouts: [computeBindGroupLayout] }),
    compute: { module: computeModule, entryPoint: 'main' }
  });

  const renderModule = device.createShaderModule({
    code: /* wgsl */`
      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) uv: vec2<f32>,
      }

      @vertex
      fn vs(@builtin(vertex_index) i: u32) -> VertexOutput {
        var pos = array<vec2<f32>, 3>(
          vec2<f32>(-1.0, -1.0),
          vec2<f32>(3.0, -1.0),
          vec2<f32>(-1.0, 3.0)
        );
        var output: VertexOutput;
        output.position = vec4<f32>(pos[i], 0.0, 1.0);
        output.uv = pos[i] * 0.5 + 0.5;
        return output;
      }

      struct RenderUniforms {
        time: f32,
      }
      @group(0) @binding(0) var tex: texture_2d<f32>;
      @group(0) @binding(1) var samp: sampler;

      ${renderCode}

      @fragment
      fn fs(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
        let data = textureSample(tex, samp, uv);
        return render(data, uv);
      }
    `
  });

  const renderPipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: { module: renderModule, entryPoint: 'vs' },
    fragment: { module: renderModule, entryPoint: 'fs', targets: [{ format }] },
    primitive: { topology: 'triangle-list' }
  });

  const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });

  const loop = () => {
    const time = performance.now() * 0.001;

    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([
      time, mouse[0], mouse[1], mouseDown ? 1.0 : 0.0,
      mouse[2], mouse[3], width, height
    ]));

    const encoder = device.createCommandEncoder();

    const computePass = encoder.beginComputePass();
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, device.createBindGroup({
      layout: computeBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: stateA.createView() },
        { binding: 2, resource: stateB.createView() }
      ]
    }));
    computePass.dispatchWorkgroups(Math.ceil(width / 16), Math.ceil(height / 16));
    computePass.end();

    const renderPass = encoder.beginRenderPass({
      colorAttachments: [{
        view: context.getCurrentTexture().createView(),
        clearValue: [0.02, 0.05, 0.1, 1],
        loadOp: 'clear',
        storeOp: 'store'
      }]
    });
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, device.createBindGroup({
      layout: renderPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: stateB.createView() },
        { binding: 1, resource: sampler }
      ]
    }));
    renderPass.draw(3);
    renderPass.end();

    device.queue.submit([encoder.finish()]);
    [stateA, stateB] = [stateB, stateA];
    requestAnimationFrame(loop);
  };
  loop();

  console.log('%c ğŸŒŠ WebGPU Water Ready ', 'background: #0077be; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold;');
  console.log('Move mouse to create ripples! Click for bigger waves.');
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WATER SIMULATION
// Channels: R=height, G=velocity, B=normal.x, A=normal.y
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

gpu(
  // Compute shader (wave equation)
  /* wgsl */`
    fn hash(p: vec2<f32>) -> f32 {
      return fract(sin(dot(p, vec2<f32>(12.9898, 78.233))) * 43758.5453);
    }

    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      var height = data.r;
      var velocity = data.g;
      
      // Sample neighbors for wave equation
      let up = sample(C + vec2<i32>(0, 1));
      let down = sample(C - vec2<i32>(0, 1));
      let left = sample(C - vec2<i32>(1, 0));
      let right = sample(C + vec2<i32>(1, 0));
      
      // Wave equation: acceleration = cÂ² * laplacian
      let c = 0.3; // wave speed
      let laplacian = up.r + down.r + left.r + right.r - 4.0 * height;
      velocity += c * c * laplacian;
      
      // Damping
      velocity *= 0.995;
      
      // Update height
      height += velocity;
      
      // Mouse disturbance
      let mouse = vec2<f32>(u.mouseX, 1.0 - u.mouseY);
      let d = length(uv - mouse);
      let intensity = select(2.0, 8.0, u.mouseDown > 0.5);
      if (d < 0.05) {
        let falloff = 1.0 - d / 0.05;
        height += falloff * intensity * 0.1;
      }
      
      // Continuous rain drops
      let rainPos = vec2<f32>(
        fract(hash(vec2<f32>(u.time * 0.7, 0.0)) + u.time * 0.1),
        fract(hash(vec2<f32>(0.0, u.time * 0.7)) + u.time * 0.13)
      );
      let rainDist = length(uv - rainPos);
      if (rainDist < 0.02) {
        height += (1.0 - rainDist / 0.02) * 0.5;
      }
      
      // Calculate normal from height gradient
      let eps = 1.0 / u.width;
      let nx = (right.r - left.r) / (2.0 * eps);
      let ny = (up.r - down.r) / (2.0 * eps);
      
      textureStore(dst, C, vec4<f32>(
        height,
        velocity,
        nx * 0.1,
        ny * 0.1
      ));
    }
  `,
  
  // Render shader (water surface)
  /* wgsl */`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let height = data.r;
      let nx = data.b;
      let ny = data.a;
      
      let normal = normalize(vec3<f32>(-nx, -ny, 1.0));
      
      // View and light
      let viewDir = normalize(vec3<f32>(uv - 0.5, 1.5));
      let lightDir = normalize(vec3<f32>(0.5, 0.8, 0.6));
      
      // Sky color for reflection
      let skyColor = vec3<f32>(0.4, 0.6, 0.9);
      let deepColor = vec3<f32>(0.02, 0.08, 0.15);
      let waterColor = vec3<f32>(0.05, 0.15, 0.25);
      
      // Reflection
      let refl = reflect(-viewDir, normal);
      let fresnel = pow(1.0 - max(0.0, dot(viewDir, normal)), 4.0);
      
      // Sky reflection
      var skyRefl = skyColor + vec3<f32>(0.3, 0.2, 0.1) * pow(max(0.0, refl.y), 3.0);
      
      // Sun specular
      let spec = pow(max(0.0, dot(refl, lightDir)), 128.0);
      skyRefl += vec3<f32>(1.0, 0.95, 0.8) * spec * 2.0;
      
      // Water base color
      let depth = 0.5 - uv.y + height * 0.5;
      var refr = mix(waterColor, deepColor, clamp(depth, 0.0, 1.0));
      
      // Caustics approximation
      let caustic = pow(abs(sin(uv.x * 30.0 + nx * 5.0) * sin(uv.y * 30.0 + ny * 5.0)), 8.0);
      refr += vec3<f32>(0.5, 0.6, 0.7) * caustic * exp(-depth * 3.0);
      
      // Mix based on fresnel
      var col = mix(refr, skyRefl, fresnel * 0.8);
      
      // Foam on wave crests
      let foam = smoothstep(0.1, 0.2, height);
      col = mix(col, vec3<f32>(0.95, 0.98, 1.0), foam * 0.5);
      
      // Tone mapping
      col = col / (col + 1.0);
      col = pow(col, vec3<f32>(0.85));
      
      return vec4<f32>(col, 1.0);
    }
  `
);
</script>
</body>
</html>