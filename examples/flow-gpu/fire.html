<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” GPU Flow Fire Demo</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; }
    .info { position: fixed; top: 10px; left: 10px; color: #fff; font: 14px monospace; 
            background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 6px; z-index: 100; }
    .info code { color: #ff6622; }
    .home-link { position: fixed; bottom: 1rem; right: 1rem; background: linear-gradient(135deg, #ff6b6b, #feca57); 
                 color: #000; padding: 0.75rem 1.5rem; border-radius: 25px; text-decoration: none; 
                 font-weight: bold; font-size: 0.85rem; box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3); 
                 transition: all 0.2s; z-index: 100; font-family: monospace; }
    .home-link:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4); }
    .home-link.hidden { display: none; }
  </style>
</head>
<body>
<div class="info">ğŸ”¥ <code>mushu().gpu().flow()</code> Candle Flame | Move mouse to position flame</div>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { mushu } from '../../src/index.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YOGPU Candle Flame - Interactive flame that follows mouse
// 
// Features:
//   â€¢ Realistic candle/match flame shape
//   â€¢ Flame follows mouse position
//   â€¢ Flickering and dancing motion
//   â€¢ Proper blackbody coloring
//   â€¢ Blue base like real candle flames
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

mushu('#c').gpu().flow()
  .display(`
    fn hash(p: vec2<f32>) -> f32 {
      var p3 = fract(vec3<f32>(p.xyx) * 0.1031);
      p3 = p3 + dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
      );
    }
    
    fn fbm(p: vec2<f32>, octaves: i32) -> f32 {
      var value = 0.0;
      var amplitude = 0.5;
      var pos = p;
      for (var i = 0; i < 6; i++) {
        if (i >= octaves) { break; }
        value += amplitude * noise(pos);
        pos = pos * 2.0 + vec2<f32>(1.7, 3.2);
        amplitude *= 0.5;
      }
      return value;
    }

    @fragment fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
      let aspect = resolution.x / resolution.y;
      let t = time;
      
      // Mouse position is the flame base
      var flameBase = mouse;
      flameBase.y = 1.0 - flameBase.y;
      
      // Position relative to flame base
      var p = uv - flameBase;
      p.x *= aspect;
      p.y = -p.y; // Flame goes UP
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Candle Flame Shape
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Gentle sway
      let sway = sin(t * 3.0) * 0.015 + sin(t * 7.3) * 0.008 + sin(t * 11.0) * 0.004;
      p.x -= sway * p.y * 2.0;
      
      // Flame dimensions
      let flameHeight = 0.22;
      let flameWidth = 0.032;
      
      // Normalized height
      let normalizedY = clamp(p.y / flameHeight, 0.0, 1.0);
      
      // Teardrop profile
      let widthProfile = sin(normalizedY * 3.14159) * (1.0 - normalizedY * 0.4);
      let currentWidth = flameWidth * (0.25 + widthProfile * 0.75);
      
      // Distance from center
      let xDist = abs(p.x) / currentWidth;
      
      // In flame zone
      let inFlameY = step(0.0, p.y) * step(p.y, flameHeight);
      
      // Flame intensity
      var flame = (1.0 - xDist) * inFlameY;
      flame = max(0.0, flame);
      flame = pow(flame, 0.6);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Turbulence & Flickering
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Edge turbulence
      let turb = fbm(vec2<f32>(p.x * 15.0, p.y * 15.0 - t * 8.0), 4);
      flame *= 0.7 + turb * 0.5;
      
      // Inner core (less turbulent)
      let innerFlame = pow(max(0.0, 1.0 - xDist * 1.5), 2.0) * inFlameY;
      
      // Wispy tip
      let wispY = (p.y - flameHeight * 0.65) / (flameHeight * 0.35);
      if (wispY > 0.0) {
        let wisp = fbm(vec2<f32>(p.x * 30.0, -t * 12.0), 3);
        flame *= max(0.0, 1.0 - wispY + wisp * 0.5);
      }
      
      // Global flicker
      let flicker = 0.88 + 0.12 * sin(t * 15.0) * sin(t * 23.0);
      flame *= flicker;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Blackbody Colors
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      var color = vec3<f32>(0.0);
      
      // Dark red outer
      color += vec3<f32>(0.4, 0.02, 0.0) * pow(flame, 0.5) * 0.5;
      
      // Orange
      color += vec3<f32>(1.0, 0.35, 0.0) * pow(flame, 0.8) * 1.2;
      
      // Yellow
      color += vec3<f32>(1.0, 0.7, 0.15) * pow(flame, 1.2) * 1.5;
      
      // White-hot core
      let core = pow(innerFlame, 2.0) * (1.0 - normalizedY);
      color += vec3<f32>(0.9, 0.95, 1.0) * core * 2.0;
      
      // Blue base (real candle characteristic)
      let blueBase = max(0.0, 1.0 - normalizedY * 3.0) * innerFlame;
      color = mix(color, vec3<f32>(0.3, 0.5, 1.0), blueBase * 0.4);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Ember/Wick Glow
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let emberDist = length(p * vec2<f32>(1.0, 3.0));
      let ember = exp(-emberDist * 40.0) * 0.8;
      color += vec3<f32>(1.0, 0.4, 0.1) * ember;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Atmospheric Glow
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let glowDist = length(p * vec2<f32>(1.0, 0.5));
      let glow = exp(-glowDist * 8.0) * 0.3;
      color += vec3<f32>(1.0, 0.3, 0.05) * glow;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Background & Final
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let bg = vec3<f32>(0.01, 0.01, 0.02);
      let ambient = exp(-length(uv - vec2<f32>(flameBase.x, 1.0 - flameBase.y)) * 3.0);
      var finalColor = bg + vec3<f32>(0.15, 0.05, 0.02) * ambient;
      
      finalColor += color;
      
      // Tone mapping
      finalColor = finalColor / (finalColor + 0.8);
      finalColor = pow(finalColor, vec3<f32>(0.9));
      
      // Vignette
      let vignette = 1.0 - length(uv - 0.5) * 0.4;
      finalColor *= vignette;
      
      return vec4<f32>(finalColor, 1.0);
    }
  `)
  .go();

// FPS Counter
(function() {
  const fpsDiv = document.createElement('div');
  fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
  document.body.appendChild(fpsDiv);
  let frames = 0, lastTime = performance.now();
  function updateFPS() {
    frames++;
    const now = performance.now();
    if (now - lastTime >= 500) {
      fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
      frames = 0; lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();

console.log('%c ğŸ”¥ YOGPU Candle Flame ', 'background: linear-gradient(90deg, #ff4400, #ff8800); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Move mouse to position the flame!');
</script>
<script>
// Hide home-link if in iframe - run immediately and on load
function hideIfIframe() {
  if (window.self !== window.top) {
    const link = document.querySelector('.home-link');
    if (link) {
      link.style.display = 'none';
    }
  }
}
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hideIfIframe);
} else {
  hideIfIframe();
}
</script>
<a href="index.html" class="home-link">â† Back to Index</a>
</body>
</html>
