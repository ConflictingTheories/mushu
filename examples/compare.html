<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu ‚Äî Code Comparison</title>
  <link rel="stylesheet" href="./compare.css">
  <link rel="stylesheet" href="./support.css">
</head>
<body>

<header>
  <h1>üç° mushu - Code Comparison</h1>
  <p class="subtitle">WebGL & WebGPU creative coding made ridiculously simple</p>
  
  <div class="stats-bar">
    <div class="stat">
      <div class="stat-value">~280</div>
      <div class="stat-label">Lines Before (fire.html)</div>
    </div>
    <div class="stat">
      <div class="stat-value green">~95</div>
      <div class="stat-label">Lines After (mushu fire)</div>
    </div>
    <div class="stat">
      <div class="stat-value purple">66%</div>
      <div class="stat-label">Code Reduction</div>
    </div>
  </div>
</header>

<nav id="nav">
  <a href="#plasma" class="active">Plasma (WebGL)</a>
  <a href="#fire">Fire (WebGL)</a>
  <a href="#water">Water (WebGL)</a>
  <a href="#gpu/plasma">Plasma (WebGPU)</a>
  <a href="#gpu/fire">Fire (WebGPU)</a>
</nav>

<div class="philosophy">
  <h3>ü™ù The Hookable Fluent Pattern</h3>
  <p>
    Traditional graphics APIs force you to learn everything upfront ‚Äî context creation, shader compilation, 
    buffer management, uniform binding, render loops... <strong>mushu flips this completely</strong>.
    Start with <code>mushu(canvas).flow().use(shader(`...`)).go()</code> and you have a working shader in 3 lines.
    Need ping-pong FBOs for simulation? Add <code>.use(simulation())</code>. 
    Need WebGPU compute? Use <code>mushu().gpu(computeCode, renderCode)</code>.
    Each hook is chainable, each default is overridable, and hot-reloading is built-in.
  </p>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- PLASMA COMPARISON -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<section id="plasma">
  <h2>üåà Plasma Effect ‚Äî WebGL</h2>
  
  <div class="demo-links">
    <a href="./glsl/plasma.html" class="demo-link">‚ñ∂ Run mushu Plasma</a>
    <a href="./boilerplate/plasma.html" class="demo-link secondary">‚ñ∂ Run Original</a>
  </div>
  
  <div class="comparison-grid">
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title before">‚ùå Traditional WebGL (~190 lines)</span>
        <span class="line-count">Full boilerplate</span>
      </div>
      <pre><code><span class="keyword">const</span> canvas = document.<span class="function">createElement</span>(<span class="string">'canvas'</span>);
document.body.<span class="function">appendChild</span>(canvas);
canvas.style.cssText = <span class="string">'position:fixed;inset:0;width:100%;height:100%'</span>;

<span class="keyword">const</span> gl = canvas.<span class="function">getContext</span>(<span class="string">'webgl2'</span>);
<span class="keyword">if</span> (!gl) { <span class="function">alert</span>(<span class="string">'WebGL2 not supported'</span>); }

<span class="comment">// Auto resize with devicePixelRatio</span>
<span class="keyword">const</span> <span class="function">resize</span> = () => {
  <span class="keyword">const</span> d = devicePixelRatio;
  canvas.width  = innerWidth  * d;
  canvas.height = innerHeight * d;
  gl.<span class="function">viewport</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);
};
<span class="function">resize</span>();
<span class="function">addEventListener</span>(<span class="string">'resize'</span>, resize);

<span class="comment">// Mouse tracking</span>
<span class="keyword">const</span> mouse = [<span class="number">0</span>, <span class="number">0</span>];
<span class="keyword">let</span> mouseDown = <span class="keyword">false</span>;
<span class="function">addEventListener</span>(<span class="string">'mousemove'</span>, e => {
  <span class="keyword">const</span> r = canvas.<span class="function">getBoundingClientRect</span>();
  mouse[<span class="number">0</span>] = (e.clientX - r.left) / r.width  * <span class="number">2</span> - <span class="number">1</span>;
  mouse[<span class="number">1</span>] = <span class="number">1</span> - (e.clientY - r.top) / r.height * <span class="number">2</span>;
});
<span class="function">addEventListener</span>(<span class="string">'mousedown'</span>, () => mouseDown = <span class="keyword">true</span>);
<span class="function">addEventListener</span>(<span class="string">'mouseup'</span>, () => mouseDown = <span class="keyword">false</span>);

<span class="comment">// Fullscreen triangle VAO</span>
<span class="keyword">const</span> vao = gl.<span class="function">createVertexArray</span>();
gl.<span class="function">bindVertexArray</span>(vao);

<span class="comment">// Vertex shader</span>
<span class="keyword">const</span> vsSource = <span class="string">`#version 300 es
void main() {
  vec2 positions[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(positions[gl_VertexID], 0, 1);
}`</span>;

<span class="comment">// Fragment shader with uniforms</span>
<span class="keyword">const</span> fsSource = <span class="string">`#version 300 es
precision highp float;
out vec4 O;
uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;
uniform float mouseDown;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  // ... plasma logic ...
}

void main() { mainImage(O, gl_FragCoord.xy); }
`</span>;

<span class="comment">// Shader compilation function</span>
<span class="keyword">function</span> <span class="function">compileShader</span>(source, type) {
  <span class="keyword">const</span> shader = gl.<span class="function">createShader</span>(type);
  gl.<span class="function">shaderSource</span>(shader, source);
  gl.<span class="function">compileShader</span>(shader);
  <span class="keyword">if</span> (!gl.<span class="function">getShaderParameter</span>(shader, gl.COMPILE_STATUS)) {
    console.<span class="function">error</span>(<span class="string">'Shader error:'</span>, gl.<span class="function">getShaderInfoLog</span>(shader));
    <span class="keyword">return</span> <span class="keyword">null</span>;
  }
  <span class="keyword">return</span> shader;
}

<span class="comment">// Compile shaders</span>
<span class="keyword">const</span> vs = <span class="function">compileShader</span>(vsSource, gl.VERTEX_SHADER);
<span class="keyword">const</span> fs = <span class="function">compileShader</span>(fsSource, gl.FRAGMENT_SHADER);

<span class="comment">// Create and link program</span>
<span class="keyword">const</span> program = gl.<span class="function">createProgram</span>();
gl.<span class="function">attachShader</span>(program, vs);
gl.<span class="function">attachShader</span>(program, fs);
gl.<span class="function">linkProgram</span>(program);

<span class="keyword">if</span> (!gl.<span class="function">getProgramParameter</span>(program, gl.LINK_STATUS)) {
  console.<span class="function">error</span>(<span class="string">'Link error:'</span>, gl.<span class="function">getProgramInfoLog</span>(program));
}

<span class="comment">// Get uniform locations</span>
<span class="keyword">const</span> uTime = gl.<span class="function">getUniformLocation</span>(program, <span class="string">'time'</span>);
<span class="keyword">const</span> uResolution = gl.<span class="function">getUniformLocation</span>(program, <span class="string">'resolution'</span>);
<span class="keyword">const</span> uMouse = gl.<span class="function">getUniformLocation</span>(program, <span class="string">'mouse'</span>);
<span class="keyword">const</span> uMouseDown = gl.<span class="function">getUniformLocation</span>(program, <span class="string">'mouseDown'</span>);

<span class="comment">// Render loop</span>
<span class="keyword">const</span> <span class="function">loop</span> = (t) => {
  gl.<span class="function">useProgram</span>(program);
  gl.<span class="function">uniform1f</span>(uTime, t * <span class="number">0.001</span>);
  gl.<span class="function">uniform2f</span>(uResolution, canvas.width, canvas.height);
  gl.<span class="function">uniform2f</span>(uMouse, mouse[<span class="number">0</span>], mouse[<span class="number">1</span>]);
  gl.<span class="function">uniform1f</span>(uMouseDown, mouseDown ? <span class="number">1.0</span> : <span class="number">0.0</span>);
  gl.<span class="function">drawArrays</span>(gl.TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);
  <span class="function">requestAnimationFrame</span>(loop);
};
<span class="function">requestAnimationFrame</span>(loop);</code></pre>
    </div>
    
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title after">‚úÖ mushu (~35 lines)</span>
        <span class="line-count reduced">82% reduction</span>
      </div>
      <pre><code><span class="keyword">import</span> { mushu, shader, fps } <span class="keyword">from</span> <span class="string">'mushu'</span>;

<span class="function">mushu</span>(<span class="string">'#c'</span>).<span class="function">gl</span>().<span class="function">flow</span>()
  .<span class="function">use</span>(<span class="function">shader</span>(<span class="string">`
    void mainImage(out vec4 O, vec2 C) {
      vec2 uv = C / resolution;
      vec2 p = (C - resolution * 0.5) / resolution.y;
      
      <span class="comment">// Mouse influence</span>
      p += (mouse - 0.5) * 0.6;
      
      float t = time * 0.5;
      float v = 0.0;
      
      <span class="comment">// Plasma wave patterns</span>
      v += sin(p.x * 10.0 + t);
      v += sin(p.y * 10.0 + t * 0.5);
      v += sin((p.x + p.y) * 10.0 + t * 0.3);
      v += sin(length(p) * 15.0 - t * 2.0);
      v *= 0.25;
      
      <span class="comment">// Rainbow palette</span>
      vec3 col = 0.5 + 0.5 * cos(t + v * 3.0 + p.xyx * 2.0 + vec3(0,2,4));
      
      <span class="comment">// Click glow</span>
      if (mouseDown > 0.5) {
        float d = length(p - (mouse - 0.5) * 0.6);
        col += vec3(1.0, 0.8, 0.5) * exp(-d * 5.0) * 2.0;
      }
      
      <span class="comment">// Vignette</span>
      col *= 1.0 - 0.3 * length(uv - 0.5);
      O = vec4(col, 1.0);
    }
  `</span>))
  .<span class="function">use</span>(<span class="function">fps</span>())
  .<span class="function">go</span>();

<span class="comment">// That's it! mushu handles:</span>
<span class="comment">// ‚úì WebGL2 context creation</span>
<span class="comment">// ‚úì Shader compilation & error handling</span>
<span class="comment">// ‚úì Auto uniforms (time, resolution, mouse, mouseDown)</span>
<span class="comment">// ‚úì Fullscreen triangle geometry</span>
<span class="comment">// ‚úì DPR-aware resize handling</span>
<span class="comment">// ‚úì Mouse & touch tracking</span>
<span class="comment">// ‚úì Animation loop</span>
<span class="comment">// ‚úì FPS counter</span></code></pre>
    </div>
  </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- FIRE COMPARISON -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<section id="fire">
  <h2>üî• Fire Simulation ‚Äî WebGL</h2>
  
  <div class="demo-links">
    <a href="./glsl/fire.html" class="demo-link">‚ñ∂ Run mushu Fire</a>
    <a href="./boilerplate/fire.html" class="demo-link secondary">‚ñ∂ Run Original</a>
  </div>
  
  <div class="comparison-grid">
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title before">‚ùå Traditional WebGL (~280 lines)</span>
        <span class="line-count">Ping-pong FBOs + shaders</span>
      </div>
      <pre><code><span class="comment">// Everything from basic WebGL PLUS:</span>

<span class="comment">// Enable float textures extension</span>
gl.<span class="function">getExtension</span>(<span class="string">'EXT_color_buffer_float'</span>);

<span class="comment">// Create two framebuffers for ping-pong</span>
<span class="keyword">function</span> <span class="function">createFBO</span>(width, height) {
  <span class="keyword">const</span> tex = gl.<span class="function">createTexture</span>();
  gl.<span class="function">bindTexture</span>(gl.TEXTURE_2D, tex);
  gl.<span class="function">texImage2D</span>(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA16F, 
    width, height, <span class="number">0</span>, gl.RGBA, gl.HALF_FLOAT, <span class="keyword">null</span>);
  gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  
  <span class="keyword">const</span> fb = gl.<span class="function">createFramebuffer</span>();
  gl.<span class="function">bindFramebuffer</span>(gl.FRAMEBUFFER, fb);
  gl.<span class="function">framebufferTexture2D</span>(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
    gl.TEXTURE_2D, tex, <span class="number">0</span>);
  
  <span class="keyword">return</span> { tex, fb };
}

<span class="keyword">let</span> fboA = <span class="function">createFBO</span>(width, height);
<span class="keyword">let</span> fboB = <span class="function">createFBO</span>(width, height);

<span class="comment">// Simulation shader (reads from backbuffer)</span>
<span class="comment">// ... 80+ lines of fire physics ...</span>

<span class="comment">// Display shader (colorizes the simulation)</span>
<span class="comment">// ... 40+ lines of fire coloring ...</span>

<span class="comment">// Render loop with FBO ping-pong</span>
<span class="keyword">const</span> <span class="function">loop</span> = (t) => {
  <span class="comment">// Simulation pass (render to FBO B)</span>
  gl.<span class="function">bindFramebuffer</span>(gl.FRAMEBUFFER, fboB.fb);
  gl.<span class="function">viewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);
  gl.<span class="function">useProgram</span>(simProgram);
  gl.<span class="function">activeTexture</span>(gl.TEXTURE0);
  gl.<span class="function">bindTexture</span>(gl.TEXTURE_2D, fboA.tex);
  gl.<span class="function">uniform1i</span>(gl.<span class="function">getUniformLocation</span>(simProgram, <span class="string">'backbuffer'</span>), <span class="number">0</span>);
  <span class="comment">// ... set all other uniforms ...</span>
  gl.<span class="function">drawArrays</span>(gl.TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);
  
  <span class="comment">// Display pass (render to screen)</span>
  gl.<span class="function">bindFramebuffer</span>(gl.FRAMEBUFFER, <span class="keyword">null</span>);
  gl.<span class="function">viewport</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);
  gl.<span class="function">useProgram</span>(displayProgram);
  gl.<span class="function">bindTexture</span>(gl.TEXTURE_2D, fboB.tex);
  gl.<span class="function">drawArrays</span>(gl.TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);
  
  <span class="comment">// Swap FBOs</span>
  [fboA, fboB] = [fboB, fboA];
  
  <span class="function">requestAnimationFrame</span>(loop);
};</code></pre>
    </div>
    
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title after">‚úÖ mushu (~95 lines)</span>
        <span class="line-count reduced">66% reduction</span>
      </div>
      <pre><code><span class="keyword">import</span> { mushu, simulation, fps } <span class="keyword">from</span> <span class="string">'mushu'</span>;

<span class="keyword">const</span> sim = <span class="function">simulation</span>({ scale: <span class="number">0.5</span>, iterations: <span class="number">2</span> });

<span class="comment">// Simulation: Just the physics, no boilerplate</span>
sim.<span class="function">simulate</span>(<span class="string">`
  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec4 data = sample(vec2(0));
    
    float fuel = data.r;
    float heat = data.g;
    float smoke = data.b;
    
    <span class="comment">// Sample neighbors</span>
    vec4 up = sample(vec2(0, 1));
    vec4 down = sample(vec2(0, -1));
    vec4 left = sample(vec2(-1, 0));
    vec4 right = sample(vec2(1, 0));
    
    <span class="comment">// Heat diffusion & combustion</span>
    // ... physics logic ...
    
    O = vec4(clamp(fuel,0.,20.), clamp(heat,0.,20.), 
             clamp(smoke,0.,15.), 1.0);
  }
`</span>);

<span class="comment">// Display: Just the coloring</span>
sim.<span class="function">display</span>(<span class="string">`
  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec4 data = texture(backbuffer, uv);
    float heat = data.g, smoke = data.b;
    
    vec3 col = vec3(0);
    col += vec3(1.0, 1.0, 0.95) * pow(heat, 4.0) * 3.0;
    col += vec3(1.0, 0.6, 0.1) * pow(heat, 2.0) * 2.0;
    col += vec3(0.8, 0.2, 0.0) * pow(heat, 1.0) * 1.0;
    
    col = mix(col, vec3(0.02), 1.0 - exp(-smoke * 0.3));
    col = 1.0 - exp(-col * 0.6);
    
    O = vec4(col, 1.0);
  }
`</span>);

<span class="function">mushu</span>(<span class="string">'#c'</span>).<span class="function">gl</span>().<span class="function">flow</span>()
  .<span class="function">use</span>(sim)
  .<span class="function">use</span>(<span class="function">fps</span>())
  .<span class="function">go</span>();

<span class="comment">// simulation() handles all the complexity:</span>
<span class="comment">// ‚úì Float texture framebuffers</span>
<span class="comment">// ‚úì Ping-pong buffer swapping</span>
<span class="comment">// ‚úì sample() helper function</span>
<span class="comment">// ‚úì Resolution scaling</span>
<span class="comment">// ‚úì Multiple iterations per frame</span>
<span class="comment">// ‚úì Resize handling</span></code></pre>
    </div>
  </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- WATER COMPARISON -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<section id="water">
  <h2>üåä Water Simulation ‚Äî WebGL</h2>
  
  <div class="demo-links">
    <a href="./glsl/water.html" class="demo-link">‚ñ∂ Run mushu Water</a>
    <a href="./boilerplate/water.html" class="demo-link secondary">‚ñ∂ Run Original</a>
  </div>
  
  <div class="comparison-grid">
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title before">‚ùå Traditional WebGL (~250 lines)</span>
        <span class="line-count">Complex wave simulation</span>
      </div>
      <pre><code><span class="comment">// Same boilerplate as fire...</span>
<span class="comment">// FBO setup, shader compilation, uniforms...</span>

<span class="comment">// Wave equation solver</span>
<span class="keyword">const</span> waveShader = <span class="string">`
  // Previous height, current height, velocity
  vec4 data = texture(backbuffer, uv);
  
  // Sample neighbors for Laplacian
  float n = texture(backbuffer, uv + vec2(0, dy)).r;
  float s = texture(backbuffer, uv - vec2(0, dy)).r;
  float e = texture(backbuffer, uv + vec2(dx, 0)).r;
  float w = texture(backbuffer, uv - vec2(dx, 0)).r;
  
  // Wave equation: d¬≤h/dt¬≤ = c¬≤ * ‚àá¬≤h
  float laplacian = (n + s + e + w - 4.0 * data.r) / (dx * dx);
  float acc = laplacian * c * c;
  
  // Verlet integration
  float newHeight = 2.0 * data.r - data.g + acc * dt * dt;
  
  // Apply damping
  newHeight *= 0.998;
  
  // Mouse ripples
  if (mouseDown > 0.5) {
    float d = length(uv - mouse);
    newHeight += exp(-d * 50.0) * 0.5;
  }
`</span>;

<span class="comment">// Rendering with normals & reflections</span>
<span class="keyword">const</span> renderShader = <span class="string">`
  // Calculate normals from height field
  vec3 normal = normalize(vec3(
    (e - w) / (2.0 * dx),
    (n - s) / (2.0 * dy),
    1.0
  ));
  
  // Fresnel, reflections, caustics...
`</span>;</code></pre>
    </div>
    
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title after">‚úÖ mushu (~70 lines)</span>
        <span class="line-count reduced">72% reduction</span>
      </div>
      <pre><code><span class="keyword">import</span> { mushu, simulation, fps } <span class="keyword">from</span> <span class="string">'mushu'</span>;

<span class="keyword">const</span> water = <span class="function">simulation</span>({ scale: <span class="number">0.5</span> });

water.<span class="function">simulate</span>(<span class="string">`
  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec4 data = sample(vec2(0));
    
    // Wave equation with sample() helper
    float n = sample(vec2(0, 1)).r;
    float s = sample(vec2(0, -1)).r;
    float e = sample(vec2(1, 0)).r;
    float w = sample(vec2(-1, 0)).r;
    
    float laplacian = n + s + e + w - 4.0 * data.r;
    float acc = laplacian * 0.25;
    
    float h = 2.0 * data.r - data.g + acc;
    h *= 0.998;  // Damping
    
    // Mouse creates ripples
    if (mouseDown > 0.5) {
      float d = length(uv - mouse);
      h += exp(-d * 50.0) * 0.3;
    }
    
    O = vec4(h, data.r, 0, 1);
  }
`</span>);

water.<span class="function">display</span>(<span class="string">`
  void mainImage(out vec4 O, vec2 C) {
    // Normal-based rendering with Fresnel
    // ... clean rendering code ...
  }
`</span>);

<span class="function">mushu</span>(<span class="string">'#c'</span>).<span class="function">gl</span>().<span class="function">flow</span>()
  .<span class="function">use</span>(water)
  .<span class="function">use</span>(<span class="function">fps</span>())
  .<span class="function">go</span>();</code></pre>
    </div>
  </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- WEBGPU PLASMA COMPARISON -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<section id="gpu/plasma">
  <h2>üåà Plasma Effect ‚Äî WebGPU</h2>
  
  <div class="demo-links">
    <a href="./gpu/plasma.html" class="demo-link gpu">‚ñ∂ Run mushu WebGPU Plasma</a>
  </div>
  
  <div class="comparison-grid">
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title before">‚ùå Traditional WebGPU (~200 lines)</span>
        <span class="line-count">Device, pipelines, bind groups...</span>
      </div>
      <pre><code><span class="comment">// Request adapter and device</span>
<span class="keyword">const</span> adapter = <span class="keyword">await</span> navigator.gpu.<span class="function">requestAdapter</span>();
<span class="keyword">const</span> device = <span class="keyword">await</span> adapter.<span class="function">requestDevice</span>();
<span class="keyword">const</span> context = canvas.<span class="function">getContext</span>(<span class="string">'webgpu'</span>);
<span class="keyword">const</span> format = navigator.gpu.<span class="function">getPreferredCanvasFormat</span>();
context.<span class="function">configure</span>({ device, format, alphaMode: <span class="string">'premultiplied'</span> });

<span class="comment">// Create uniform buffer</span>
<span class="keyword">const</span> uniformBuffer = device.<span class="function">createBuffer</span>({
  size: <span class="number">48</span>,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

<span class="comment">// Create shader module</span>
<span class="keyword">const</span> shaderModule = device.<span class="function">createShaderModule</span>({
  code: <span class="string">`
    struct Uniforms { time: f32, ... }
    @group(0) @binding(0) var<uniform> u: Uniforms;
    
    @vertex fn vs(...) -> ... { ... }
    @fragment fn fs(...) -> ... { ... }
  `</span>
});

<span class="comment">// Create bind group layout</span>
<span class="keyword">const</span> bindGroupLayout = device.<span class="function">createBindGroupLayout</span>({
  entries: [{
    binding: <span class="number">0</span>,
    visibility: GPUShaderStage.FRAGMENT,
    buffer: { type: <span class="string">'uniform'</span> }
  }]
});

<span class="comment">// Create render pipeline</span>
<span class="keyword">const</span> pipeline = device.<span class="function">createRenderPipeline</span>({
  layout: device.<span class="function">createPipelineLayout</span>({ 
    bindGroupLayouts: [bindGroupLayout] 
  }),
  vertex: { module: shaderModule, entryPoint: <span class="string">'vs'</span> },
  fragment: { 
    module: shaderModule, 
    entryPoint: <span class="string">'fs'</span>,
    targets: [{ format }]
  },
  primitive: { topology: <span class="string">'triangle-list'</span> }
});

<span class="comment">// Create bind group</span>
<span class="keyword">const</span> bindGroup = device.<span class="function">createBindGroup</span>({
  layout: bindGroupLayout,
  entries: [{
    binding: <span class="number">0</span>,
    resource: { buffer: uniformBuffer }
  }]
});

<span class="comment">// Render loop</span>
<span class="keyword">const</span> <span class="function">loop</span> = () => {
  device.queue.<span class="function">writeBuffer</span>(uniformBuffer, <span class="number">0</span>, 
    <span class="keyword">new</span> Float32Array([time, ...]));
  
  <span class="keyword">const</span> encoder = device.<span class="function">createCommandEncoder</span>();
  <span class="keyword">const</span> pass = encoder.<span class="function">beginRenderPass</span>({
    colorAttachments: [{
      view: context.<span class="function">getCurrentTexture</span>().<span class="function">createView</span>(),
      loadOp: <span class="string">'clear'</span>,
      storeOp: <span class="string">'store'</span>
    }]
  });
  pass.<span class="function">setPipeline</span>(pipeline);
  pass.<span class="function">setBindGroup</span>(<span class="number">0</span>, bindGroup);
  pass.<span class="function">draw</span>(<span class="number">6</span>);
  pass.<span class="function">end</span>();
  
  device.queue.<span class="function">submit</span>([encoder.<span class="function">finish</span>()]);
  <span class="function">requestAnimationFrame</span>(loop);
};</code></pre>
    </div>
    
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title after">‚úÖ mushu gpu() (~25 lines)</span>
        <span class="line-count reduced">88% reduction</span>
      </div>
      <pre><code><span class="keyword">import</span> { mushu } <span class="keyword">from</span> <span class="string">'mushu'</span>;

<span class="function">mushu</span>(<span class="string">'#c'</span>).<span class="function">gpu</span>(
  <span class="keyword">null</span>,  <span class="comment">// No compute shader needed</span>
  
  <span class="comment">// Just the render logic</span>
  <span class="string">`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let p = (uv - 0.5) * 2.0;
      let t = u.time * 0.5;
      
      var v = 0.0;
      v += sin(p.x * 10.0 + t);
      v += sin(p.y * 10.0 + t * 0.5);
      v += sin((p.x + p.y) * 10.0 + t * 0.3);
      v += sin(length(p) * 15.0 - t * 2.0);
      v *= 0.25;
      
      let col = 0.5 + 0.5 * cos(
        t + v * 3.0 + vec3<f32>(p.x, p.y, p.x) * 2.0 + 
        vec3<f32>(0.0, 2.0, 4.0)
      );
      
      return vec4<f32>(col, 1.0);
    }
  `</span>
);

<span class="comment">// gpu() handles everything:</span>
<span class="comment">// ‚úì Adapter & device request</span>
<span class="comment">// ‚úì Canvas context configuration</span>
<span class="comment">// ‚úì Uniform buffer management</span>
<span class="comment">// ‚úì Pipeline creation</span>
<span class="comment">// ‚úì Bind group setup</span>
<span class="comment">// ‚úì Command encoding</span>
<span class="comment">// ‚úì Resize handling</span></code></pre>
    </div>
  </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- WEBGPU FIRE COMPARISON -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

<section id="gpu/fire">
  <h2>üî• Fire Simulation ‚Äî WebGPU</h2>
  
  <div class="demo-links">
    <a href="./gpu/fire.html" class="demo-link gpu">‚ñ∂ Run mushu WebGPU Fire</a>
  </div>
  
  <div class="comparison-grid">
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title before">‚ùå Traditional WebGPU (~300 lines)</span>
        <span class="line-count">Device, pipelines, bind groups...</span>
      </div>
      <pre><code><span class="comment">// Request adapter and device</span>
<span class="keyword">const</span> adapter = <span class="keyword">await</span> navigator.gpu.<span class="function">requestAdapter</span>();
<span class="keyword">const</span> device = <span class="keyword">await</span> adapter.<span class="function">requestDevice</span>();

<span class="comment">// Create ping-pong storage textures</span>
<span class="keyword">const</span> <span class="function">createStateTexture</span> = () => device.<span class="function">createTexture</span>({
  size: [width, height],
  format: <span class="string">'rgba16float'</span>,
  usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
});

<span class="comment">// Create compute shader module</span>
<span class="keyword">const</span> computeModule = device.<span class="function">createShaderModule</span>({
  code: <span class="string">`
    @group(0) @binding(0) var<uniform> u: Uniforms;
    @group(0) @binding(1) var src: texture_storage_2d<rgba16float, read>;
    @group(0) @binding(2) var dst: texture_storage_2d<rgba16float, write>;
    
    @compute @workgroup_size(16, 16)
    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
      // ... fire simulation ...
    }
  `</span>
});

<span class="comment">// Create bind group layout manually</span>
<span class="keyword">const</span> computeBindGroupLayout = device.<span class="function">createBindGroupLayout</span>({
  entries: [
    { binding: <span class="number">0</span>, visibility: GPUShaderStage.COMPUTE, 
      buffer: { type: <span class="string">'uniform'</span> } },
    { binding: <span class="number">1</span>, visibility: GPUShaderStage.COMPUTE, 
      storageTexture: { access: <span class="string">'read-only'</span>, format: <span class="string">'rgba16float'</span> } },
    { binding: <span class="number">2</span>, visibility: GPUShaderStage.COMPUTE, 
      storageTexture: { access: <span class="string">'write-only'</span>, format: <span class="string">'rgba16float'</span> } }
  ]
});

<span class="comment">// Create compute pipeline</span>
<span class="keyword">const</span> computePipeline = device.<span class="function">createComputePipeline</span>({
  layout: device.<span class="function">createPipelineLayout</span>({ 
    bindGroupLayouts: [computeBindGroupLayout] 
  }),
  compute: { module: computeModule, entryPoint: <span class="string">'main'</span> }
});

<span class="comment">// ... render pipeline setup ...</span>
<span class="comment">// ... another 50+ lines ...</span></code></pre>
    </div>
    
    <div class="code-panel">
      <div class="panel-header">
        <span class="panel-title after">‚úÖ mushu gpu() (~75 lines)</span>
        <span class="line-count reduced">75% reduction</span>
      </div>
      <pre><code><span class="keyword">import</span> { mushu } <span class="keyword">from</span> <span class="string">'mushu'</span>;

<span class="function">mushu</span>(<span class="string">'#c'</span>).<span class="function">gpu</span>(
  <span class="comment">// Compute shader - just the physics logic</span>
  <span class="string">`
    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      var fuel = data.r;
      var heat = data.g;
      var smoke = data.b;
      
      <span class="comment">// Sample neighbors</span>
      let up = sample(C + vec2<i32>(0, -1));
      let down = sample(C + vec2<i32>(0, 1));
      
      <span class="comment">// Heat diffusion & buoyancy</span>
      heat += 0.12 * (up.g + down.g - 2.0 * heat);
      heat = mix(heat, down.g, 0.2);
      
      <span class="comment">// Combustion & decay</span>
      // ... physics ...
      
      textureStore(dst, C, vec4<f32>(fuel, heat, smoke, 1.0));
    }
  `</span>,
  
  <span class="comment">// Render shader - just the coloring</span>
  <span class="string">`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let heat = data.g;
      let smoke = data.b;
      
      var col = vec3<f32>(0.0);
      col += vec3<f32>(1.0, 1.0, 0.95) * pow(heat, 4.0);
      col += vec3<f32>(1.0, 0.6, 0.15) * pow(heat, 2.0);
      
      return vec4<f32>(col, 1.0);
    }
  `</span>,
  { scale: <span class="number">0.5</span> }
);

<span class="comment">// gpu() handles everything:</span>
<span class="comment">// ‚úì Adapter & device request</span>
<span class="comment">// ‚úì Storage texture creation</span>
<span class="comment">// ‚úì Ping-pong buffer management</span>
<span class="comment">// ‚úì Compute pipeline creation</span>
<span class="comment">// ‚úì Render pipeline creation</span>
<span class="comment">// ‚úì Bind group management</span>
<span class="comment">// ‚úì Command encoding</span></code></pre>
    </div>
  </div>
</section>

<script>
  // Smooth scroll and nav highlighting
  document.querySelectorAll('nav a').forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault();
      document.querySelectorAll('nav a').forEach(l => l.classList.remove('active'));
      e.target.classList.add('active');
      document.querySelector(e.target.getAttribute('href')).scrollIntoView({ behavior: 'smooth' });
    });
  });
</script>
<script src="./support.js"></script>

<footer>
  <p>Made with üç° by <a href="https://github.com/ConflictingTheories">ConflictingTheories</a> &mdash; <a href="https://github.com/ConflictingTheories/mushu">View on GitHub</a></p>
</footer>

<!-- Floating Support Button -->
<div class="support-fab" id="supportFab">
  <div class="support-popup" id="supportPopup">
    <div class="support-popup-header">
      <div class="support-popup-title">üíù Support mushu</div>
      <div class="support-popup-subtitle">Help keep this project alive!</div>
    </div>
    <div class="support-links">
      <a href="https://buymeacoffee.com/kderbyma" class="support-link" target="_blank">
        <span class="support-link-icon">‚òï</span>
        <span class="support-link-label">Buy Me a Coffee</span>
        <span class="support-link-arrow">‚Üí</span>
      </a>
      <a href="https://github.com/sponsors/ConflictingTheories" class="support-link" target="_blank">
        <span class="support-link-icon">‚≠ê</span>
        <span class="support-link-label">GitHub Sponsors</span>
        <span class="support-link-arrow">‚Üí</span>
      </a>
      <a href="https://patreon.com/kderbyma" class="support-link" target="_blank">
        <span class="support-link-icon">üéØ</span>
        <span class="support-link-label">Patreon</span>
        <span class="support-link-arrow">‚Üí</span>
      </a>
      <a href="https://ko-fi.com/kderbyma" class="support-link" target="_blank">
        <span class="support-link-icon">ü•§</span>
        <span class="support-link-label">Ko-fi</span>
        <span class="support-link-arrow">‚Üí</span>
      </a>
    </div>
  </div>
  <button class="support-fab-btn" id="supportFabBtn" aria-label="Support this project">
    üíù
  </button>
</div>

<a href="./index.html" class="home-link">‚Üê Back to Index</a>

</body>
</html>
