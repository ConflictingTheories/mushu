<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Water - Boilerplate</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
    .info { position: fixed; top: 10px; left: 10px; color: #fff; font: 14px monospace; 
            background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 6px; z-index: 100; }
    .info code { color: #3b82f6; }
  </style>
</head>
<body>
<div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Water | Click to create ripples</div>
<canvas id="canvas"></canvas>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VANILLA WEBGL2 WATER - BOILERPLATE EXAMPLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2');

if (!gl) {
  document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
  throw new Error('WebGL2 not supported');
}

gl.getExtension('EXT_color_buffer_float');

const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

const simulationFragSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform sampler2D uState;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform float uMouseDown;

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 texel = 1.0 / uResolution;
  
  // State: r=height, g=velocity, b=previous height
  vec4 state = texture(uState, uv);
  float height = state.r;
  float velocity = state.g;
  float prevHeight = state.b;
  
  // Sample neighbors for wave equation
  float up = texture(uState, uv + vec2(0, texel.y)).r;
  float down = texture(uState, uv - vec2(0, texel.y)).r;
  float left = texture(uState, uv - vec2(texel.x, 0)).r;
  float right = texture(uState, uv + vec2(texel.x, 0)).r;
  
  // Diagonal neighbors for smoother waves
  float upLeft = texture(uState, uv + vec2(-texel.x, texel.y)).r;
  float upRight = texture(uState, uv + vec2(texel.x, texel.y)).r;
  float downLeft = texture(uState, uv + vec2(-texel.x, -texel.y)).r;
  float downRight = texture(uState, uv + vec2(texel.x, -texel.y)).r;
  
  // Wave equation with 8-point Laplacian for smoother results
  float laplacian = (up + down + left + right) * 0.2 + 
                    (upLeft + upRight + downLeft + downRight) * 0.05 - 
                    height * 1.0;
  
  // Wave propagation
  float speed = 0.98;
  velocity += laplacian * speed;
  velocity *= 0.997; // Damping
  
  float newHeight = height + velocity * 0.5;
  
  // Mouse interaction - create ripples
  float d = length(uv - uMouse);
  if (uMouseDown > 0.5 && d < 0.06) {
    float ripple = (1.0 - d / 0.06);
    ripple = ripple * ripple * ripple;
    newHeight += ripple * 2.5;
  }
  
  // Random raindrops
  float rain = fract(sin(dot(floor(uv * 50.0 + uTime * 2.0), vec2(127.1, 311.7))) * 43758.5453);
  if (rain > 0.9998) {
    newHeight += 1.5;
  }
  
  // Edge damping
  float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));
  edge = smoothstep(0.0, 0.1, edge);
  newHeight *= edge;
  velocity *= edge;
  
  fragColor = vec4(newHeight, velocity, height, 1.0);
}`;

const displayFragSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform sampler2D uState;
uniform vec2 uResolution;
uniform float uTime;

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 texel = 1.0 / uResolution;
  
  float height = texture(uState, uv).r;
  
  // Calculate normals from height field
  float dx = texture(uState, uv + vec2(texel.x, 0)).r - texture(uState, uv - vec2(texel.x, 0)).r;
  float dy = texture(uState, uv + vec2(0, texel.y)).r - texture(uState, uv - vec2(0, texel.y)).r;
  vec3 normal = normalize(vec3(-dx * 30.0, -dy * 30.0, 1.0));
  
  // Refraction offset
  vec2 refractOffset = normal.xy * 0.03;
  vec2 refractUV = uv + refractOffset;
  
  // Deep water gradient
  vec3 deepColor = vec3(0.01, 0.05, 0.15);
  vec3 shallowColor = vec3(0.1, 0.4, 0.5);
  vec3 waterColor = mix(deepColor, shallowColor, pow(uv.y, 0.7));
  
  // Caustics pattern
  float caustic1 = sin(refractUV.x * 40.0 + uTime * 2.0) * sin(refractUV.y * 40.0 + uTime * 1.5);
  float caustic2 = sin(refractUV.x * 25.0 - uTime * 1.5) * sin(refractUV.y * 30.0 + uTime * 2.0);
  float caustics = (caustic1 + caustic2) * 0.5 + 0.5;
  caustics = pow(caustics, 3.0) * 0.4;
  
  waterColor += vec3(0.2, 0.4, 0.5) * caustics * (1.0 - uv.y * 0.5);
  
  // Fresnel reflection
  vec3 viewDir = vec3(0, 0, 1);
  float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 4.0);
  
  // Sky reflection color
  vec3 skyColor = vec3(0.4, 0.6, 0.9);
  float skyGradient = normal.y * 0.5 + 0.5;
  skyColor = mix(vec3(0.8, 0.85, 0.9), skyColor, skyGradient);
  
  // Combine water and reflection
  vec3 color = mix(waterColor, skyColor, fresnel * 0.6);
  
  // Specular highlights
  vec3 lightDir = normalize(vec3(0.5, 0.8, 1.0));
  vec3 halfVec = normalize(lightDir + viewDir);
  float spec = pow(max(dot(normal, halfVec), 0.0), 120.0);
  color += vec3(1.0, 0.98, 0.95) * spec * 0.8;
  
  // Wave peaks are brighter (foam-like)
  float foam = smoothstep(0.3, 0.8, abs(height));
  color = mix(color, vec3(0.9, 0.95, 1.0), foam * 0.3);
  
  // Depth-based darkening
  color *= 0.85 + uv.y * 0.15;
  
  // Subtle vignette
  float vignette = 1.0 - length(uv - 0.5) * 0.3;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

function createProgram(vertSource, fragSource) {
  const vs = createShader(gl.VERTEX_SHADER, vertSource);
  const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program error:', gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const simProgram = createProgram(vertexShaderSource, simulationFragSource);
const displayProgram = createProgram(vertexShaderSource, displayFragSource);

let width, height;
let fboA, fboB, texA, texB;

function createFBO(w, h) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  
  return { fb, tex };
}

function resize() {
  const dpr = window.devicePixelRatio || 1;
  width = Math.floor(window.innerWidth * dpr * 0.5);
  height = Math.floor(window.innerHeight * dpr * 0.5);
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  
  const a = createFBO(width, height);
  const b = createFBO(width, height);
  fboA = a.fb; texA = a.tex;
  fboB = b.fb; texB = b.tex;
}

resize();
window.addEventListener('resize', resize);

let mouse = [0.5, 0.5];
let mouseDown = false;

canvas.addEventListener('mousemove', e => {
  mouse[0] = e.clientX / window.innerWidth;
  mouse[1] = 1.0 - e.clientY / window.innerHeight;
});
canvas.addEventListener('mousedown', () => mouseDown = true);
canvas.addEventListener('mouseup', () => mouseDown = false);
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length > 0) {
    mouse[0] = e.touches[0].clientX / window.innerWidth;
    mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
  }
}, { passive: false });
canvas.addEventListener('touchstart', () => mouseDown = true);
canvas.addEventListener('touchend', () => mouseDown = false);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

function render(time) {
  time *= 0.001;
  
  // Run simulation multiple times for stability
  for (let i = 0; i < 3; i++) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
    gl.viewport(0, 0, width, height);
    gl.useProgram(simProgram);
    
    gl.uniform2f(gl.getUniformLocation(simProgram, 'uResolution'), width, height);
    gl.uniform1f(gl.getUniformLocation(simProgram, 'uTime'), time);
    gl.uniform2f(gl.getUniformLocation(simProgram, 'uMouse'), mouse[0], mouse[1]);
    gl.uniform1f(gl.getUniformLocation(simProgram, 'uMouseDown'), mouseDown ? 1 : 0);
    
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texA);
    gl.uniform1i(gl.getUniformLocation(simProgram, 'uState'), 0);
    
    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    
    [fboA, fboB] = [fboB, fboA];
    [texA, texB] = [texB, texA];
  }
  
  // Display pass
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(displayProgram);
  
  gl.uniform2f(gl.getUniformLocation(displayProgram, 'uResolution'), canvas.width, canvas.height);
  gl.uniform1f(gl.getUniformLocation(displayProgram, 'uTime'), time);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.uniform1i(gl.getUniformLocation(displayProgram, 'uState'), 0);
  
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  
  requestAnimationFrame(render);
}

requestAnimationFrame(render);

console.log('%c ğŸŒŠ Vanilla WebGL2 Water ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
</script>
</body>
</html>
