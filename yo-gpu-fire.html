<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>yo() â€” Simplified WebGPU Fire Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { yoGPU } from './yo.js?v=2';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WebGPU Fire Simulation with Compute Shaders
// yoGPU() handles ping-pong textures, compute dispatch, render loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const fire = yoGPU(document.getElementById('c'));

fire.simulate(`
  @group(0) @binding(0) var<uniform> time: f32;
  @group(0) @binding(1) var<uniform> resolution: vec2f;
  @group(0) @binding(2) var<uniform> mouse: vec2f;
  @group(0) @binding(3) var<uniform> mouseDown: f32;
  @group(0) @binding(4) var input: texture_2d<f32>;
  @group(0) @binding(5) var output: texture_storage_2d<rgba16float, write>;
  
  fn sampleTex(coord: vec2i) -> vec4f {
    let dims = vec2i(textureDimensions(input));
    let c = clamp(coord, vec2i(0), dims - 1);
    return textureLoad(input, c, 0);
  }

  @compute @workgroup_size(8, 8)
  fn main(@builtin(global_invocation_id) id: vec3u) {
    let dims = textureDimensions(input);
    if (id.x >= dims.x || id.y >= dims.y) { return; }
    
    let ipos = vec2i(id.xy);
    let uv = vec2f(id.xy) / vec2f(dims);
    // In WebGPU texture space: high Y = bottom of screen
    
    var data = sampleTex(ipos);
    var fuel = data.r;
    var heat = data.g;
    var smoke = data.b;
    
    // Neighbors: in texture coords, -Y is up on screen
    let up = sampleTex(ipos + vec2i(0, -1));
    let down = sampleTex(ipos + vec2i(0, 1));
    let left = sampleTex(ipos + vec2i(-1, 0));
    let right = sampleTex(ipos + vec2i(1, 0));
    
    // Diffusion (heat spreads)
    let diffusion = 0.12;
    heat += diffusion * (up.g + down.g + left.g + right.g - 4.0 * heat);
    
    // Buoyancy (heat rises - up is -Y in texture space)
    heat = mix(heat, down.g, 0.15);
    
    // Wind effect
    heat = mix(heat, left.g, 0.02);
    
    // Fuel diffuses slower
    fuel += 0.05 * (up.r + down.r + left.r + right.r - 4.0 * fuel);
    fuel = mix(fuel, down.r, 0.08);
    
    // Decay
    fuel *= 0.97;
    heat *= 0.985;
    smoke *= 0.99;
    
    // Mouse ignition (mouse Y needs flipping)
    let mouseFlipped = vec2f(mouse.x, 1.0 - mouse.y);
    let d = length(uv - mouseFlipped);
    if (mouseDown > 0.5 && d < 0.08) {
      let intensity = (1.0 - d / 0.08) * 8.0;
      fuel += intensity;
      heat += intensity * 2.0;
    }
    
    // Fire source at bottom (high Y in texture = bottom on screen)
    if (uv.y > 0.92) {
      let pattern = sin(uv.x * 30.0 + time * 3.0) * 0.5 + 0.5;
      let pattern2 = sin(uv.x * 7.0 - time) * 0.5 + 0.5;
      if (pattern * pattern2 > 0.4) {
        let edge = (uv.y - 0.92) / 0.08;
        fuel += 1.5 * edge;
        heat += 3.0 * edge;
      }
    }
    
    // Combustion: heat consumes fuel, produces smoke
    let burn = min(heat * 0.4, fuel);
    heat += burn * 0.3;
    fuel -= burn;
    smoke += burn * 0.5;
    
    // Smoke rises
    smoke = mix(smoke, down.b, 0.1);
    
    let result = vec4f(
      clamp(fuel, 0.0, 15.0),
      clamp(heat, 0.0, 15.0),
      clamp(smoke, 0.0, 8.0),
      1.0
    );
    textureStore(output, ipos, result);
  }
`);

fire.display(`
  @fragment
  fn main(@builtin(position) pos: vec4f) -> @location(0) vec4f {
    let uv = pos.xy / resolution;
    let flippedUV = vec2f(uv.x, 1.0 - uv.y);
    let data = textureSample(simTex, texSampler, flippedUV);
    
    let fuel = data.r;
    let heat = data.g;
    let smoke = data.b;
    
    var color = vec3f(0.0);
    
    // Core (white-yellow, very hot)
    color += vec3f(1.0, 0.95, 0.8) * pow(heat, 3.5) * 4.0;
    
    // Yellow flames
    color += vec3f(1.0, 0.8, 0.2) * pow(heat, 2.0) * 2.5;
    
    // Orange flames
    color += vec3f(1.0, 0.4, 0.05) * pow(heat, 1.2) * 1.5;
    
    // Red base
    color += vec3f(0.8, 0.1, 0.0) * pow(heat, 0.7) * 0.8;
    
    // Dark smoke overlay
    color = mix(color, vec3f(0.02), clamp(smoke * 0.25, 0.0, 0.8));
    
    // Embers (fuel without heat)
    let embers = fuel * (1.0 - heat * 0.2);
    color += vec3f(1.0, 0.3, 0.0) * embers * 0.3;
    
    // Tone mapping
    color = 1.0 - exp(-color * 0.8);
    color = pow(color, vec3f(0.9));
    
    return vec4f(color, 1.0);
  }
`);

fire.go();

console.log('%c ğŸ”¥ yo() WebGPU Fire Ready ', 'background: #ff4500; color: white; padding: 4px 8px; border-radius: 4px;');
console.log('Hold & drag mouse to ignite flames!');
</script>
</body>
</html>