<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Smoke - Boilerplate</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 16px;
      border-radius: 6px;
      z-index: 100;
    }

    .info code {
      color: #3b82f6;
    }
  </style>
</head>

<body>
  <div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Smoke | Click & drag to emit smoke</div>
  <canvas id="canvas"></canvas>
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VANILLA WEBGL2 SMOKE - BOILERPLATE EXAMPLE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
      throw new Error('WebGL2 not supported');
    }

    gl.getExtension('EXT_color_buffer_float');

    const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

    const simulationFragSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform sampler2D uState;
uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;
uniform vec2 uPrevMouse;
uniform float uMouseDown;

float hash(vec2 p) {
  vec3 p3 = fract(vec3(p.xyx) * 0.1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
  
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  
  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p, int octaves) {
  float f = 0.0;
  float amp = 0.5;
  for (int i = 0; i < 6; i++) {
    if (i >= octaves) break;
    f += amp * noise(p);
    p *= 2.0;
    amp *= 0.5;
  }
  return f;
}

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 texel = 1.0 / uResolution;
  
  // State: r=density, g=velocity.x, b=velocity.y, a=vorticity
  vec4 state = texture(uState, uv);
  float density = state.r;
  vec2 velocity = state.gb;
  float vorticity = state.a;
  
  // Sample neighbors
  vec4 up = texture(uState, uv + vec2(0, texel.y));
  vec4 down = texture(uState, uv - vec2(0, texel.y));
  vec4 left = texture(uState, uv - vec2(texel.x, 0));
  vec4 right = texture(uState, uv + vec2(texel.x, 0));
  
  // Curl/vorticity calculation for realistic swirls
  float curl = (right.b - left.b) - (up.g - down.g);
  vorticity = mix(vorticity, curl * 5.0, 0.1);
  
  // Turbulent flow field
  float turb = fbm(uv * 8.0 + uTime * 0.3, 4) * 2.0 - 1.0;
  float turb2 = fbm(uv * 15.0 - uTime * 0.5, 3) * 2.0 - 1.0;
  
  // Advect with velocity field
  vec2 advectUV = uv - velocity * texel * 3.0;
  vec4 advected = texture(uState, advectUV);
  density = mix(density, advected.r, 0.95);
  
  // Buoyancy - smoke rises
  velocity.y += density * 0.002;
  velocity.y += 0.0008; // Base upward drift
  
  // Vorticity confinement (adds swirly details)
  vec2 vortForce = vec2(
    abs(up.a) - abs(down.a),
    abs(right.a) - abs(left.a)
  );
  float vortLen = length(vortForce);
  if (vortLen > 0.0001) {
    vortForce = normalize(vortForce);
    velocity += vortForce * vorticity * 0.0015;
  }
  
  // Turbulent mixing
  velocity.x += turb * 0.001;
  velocity.y += turb2 * 0.0005;
  
  // Diffusion
  density += 0.08 * (up.r + down.r + left.r + right.r - 4.0 * density);
  
  // Velocity diffusion
  velocity += 0.1 * (up.gb + down.gb + left.gb + right.gb - 4.0 * velocity);
  
  // Decay
  density *= 0.995;
  velocity *= 0.98;
  vorticity *= 0.95;
  
  // Mouse interaction
  float d = length(uv - uMouse);
  if (uMouseDown > 0.5 && d < 0.15) {
    float intensity = pow(1.0 - d / 0.15, 2.0);
    density += intensity * 3.0;
    
    // Add velocity based on mouse movement
    vec2 mouseVel = (uMouse - uPrevMouse) * 15.0;
    velocity += mouseVel * intensity;
    
    // Add some randomness
    velocity.x += (noise(uv * 100.0 + uTime * 10.0) - 0.5) * intensity * 0.1;
  }
  
  // Smoke source at bottom
  if (uv.y < 0.08) {
    float edge = 1.0 - uv.y / 0.08;
    float pattern = noise(vec2(uv.x * 20.0, uTime * 2.0));
    
    // Create discrete smoke columns
    float columns = sin(uv.x * 15.0) * 0.5 + 0.5;
    columns *= sin(uv.x * 7.0 + uTime) * 0.5 + 0.5;
    
    if (pattern > 0.4 && columns > 0.3) {
      density += edge * pattern * 2.0;
      velocity.y += edge * 0.02;
      velocity.x += (noise(vec2(uv.x * 30.0, uTime * 5.0)) - 0.5) * edge * 0.02;
    }
  }
  
  fragColor = vec4(
    clamp(density, 0.0, 10.0),
    clamp(velocity.x, -1.0, 1.0),
    clamp(velocity.y, -1.0, 1.0),
    clamp(vorticity, -5.0, 5.0)
  );
}`;

    const displayFragSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform sampler2D uState;
uniform vec2 uResolution;
uniform float uTime;

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 data = texture(uState, uv);
  
  float density = data.r;
  
  // Multi-layered smoke with depth
  float smoke1 = density;
  float smoke2 = texture(uState, uv + vec2(0.002, 0.001)).r;
  float smoke3 = texture(uState, uv - vec2(0.001, 0.002)).r;
  
  // Volumetric look with light scattering
  vec3 smokeColor = vec3(0.65, 0.68, 0.72); // Slightly blue-gray
  vec3 lightColor = vec3(1.0, 0.95, 0.9);   // Warm light from above
  
  // Density-based opacity with exponential falloff
  float alpha = 1.0 - exp(-density * 0.8);
  float alpha2 = 1.0 - exp(-smoke2 * 0.6);
  float alpha3 = 1.0 - exp(-smoke3 * 0.5);
  
  // Layer the smoke
  vec3 color = vec3(0.02, 0.02, 0.03); // Dark background
  
  // Back layer (darker, more diffuse)
  color = mix(color, smokeColor * 0.4, alpha3 * 0.5);
  
  // Middle layer
  color = mix(color, smokeColor * 0.6, alpha2 * 0.6);
  
  // Front layer with light scattering at edges
  float edgeLight = pow(density, 0.3) * 0.3;
  vec3 frontSmoke = mix(smokeColor, lightColor, edgeLight);
  color = mix(color, frontSmoke, alpha * 0.85);
  
  // Subtle top lighting
  float topLight = uv.y * 0.15;
  color += lightColor * topLight * alpha * 0.2;
  
  // Film grain for texture
  float grain = (hash(uv * uResolution + uTime) - 0.5) * 0.03;
  color += grain;
  
  // Vignette
  float vignette = 1.0 - length(uv - 0.5) * 0.4;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

    // Shader helpers
    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(vertSource, fragSource) {
      const vs = createShader(gl.VERTEX_SHADER, vertSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const simProgram = createProgram(vertexShaderSource, simulationFragSource);
    const displayProgram = createProgram(vertexShaderSource, displayFragSource);

    let width, height;
    let fboA, fboB, texA, texB;

    function createFBO(w, h) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

      return { fb, tex };
    }

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      width = Math.floor(window.innerWidth * dpr * 0.5);
      height = Math.floor(window.innerHeight * dpr * 0.5);
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;

      const a = createFBO(width, height);
      const b = createFBO(width, height);
      fboA = a.fb; texA = a.tex;
      fboB = b.fb; texB = b.tex;
    }

    resize();
    window.addEventListener('resize', resize);

    let mouse = [0.5, 0.5];
    let prevMouse = [0.5, 0.5];
    let mouseDown = false;

    canvas.addEventListener('mousemove', e => {
      prevMouse = [...mouse];
      mouse[0] = e.clientX / window.innerWidth;
      mouse[1] = 1.0 - e.clientY / window.innerHeight;
    });
    canvas.addEventListener('mousedown', () => mouseDown = true);
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length > 0) {
        prevMouse = [...mouse];
        mouse[0] = e.touches[0].clientX / window.innerWidth;
        mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
      }
    }, { passive: false });
    canvas.addEventListener('touchstart', () => mouseDown = true);
    canvas.addEventListener('touchend', () => mouseDown = false);

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    function render(time) {
      time *= 0.001;

      // Simulation pass
      gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
      gl.viewport(0, 0, width, height);
      gl.useProgram(simProgram);

      gl.uniform2f(gl.getUniformLocation(simProgram, 'uResolution'), width, height);
      gl.uniform1f(gl.getUniformLocation(simProgram, 'uTime'), time);
      gl.uniform2f(gl.getUniformLocation(simProgram, 'uMouse'), mouse[0], mouse[1]);
      gl.uniform2f(gl.getUniformLocation(simProgram, 'uPrevMouse'), prevMouse[0], prevMouse[1]);
      gl.uniform1f(gl.getUniformLocation(simProgram, 'uMouseDown'), mouseDown ? 1 : 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.uniform1i(gl.getUniformLocation(simProgram, 'uState'), 0);

      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      [fboA, fboB] = [fboB, fboA];
      [texA, texB] = [texB, texA];

      // Display pass
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(displayProgram);

      gl.uniform2f(gl.getUniformLocation(displayProgram, 'uResolution'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(displayProgram, 'uTime'), time);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.uniform1i(gl.getUniformLocation(displayProgram, 'uState'), 0);

      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // FPS Counter
    (function () {
      const fpsDiv = document.createElement('div');
      fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
      document.body.appendChild(fpsDiv);
      let frames = 0, lastTime = performance.now();
      function updateFPS() {
        frames++;
        const now = performance.now();
        if (now - lastTime >= 500) {
          fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
          frames = 0; lastTime = now;
        }
        requestAnimationFrame(updateFPS);
      }
      updateFPS();
    })();

    console.log('%c ğŸ’¨ Vanilla WebGL2 Smoke ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
  </script>
</body>

</html>