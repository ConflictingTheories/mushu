<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” WebGPU Smoke Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { gpu } from '../src/gpu/yoGPU.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WebGPU Advanced Volumetric Smoke Simulation
// 
// Features:
//   â€¢ Navier-Stokes inspired fluid dynamics
//   â€¢ Vorticity confinement for swirling details  
//   â€¢ Beer-Lambert light scattering
//   â€¢ Temperature-based buoyancy
//   â€¢ Multi-scale turbulence
// 
// Click and drag to add smoke!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

gpu(
  // Compute shader - Advanced smoke physics
  /* wgsl */`
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Noise Functions
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    fn hash(p: vec2<f32>) -> f32 {
      var p3 = fract(vec3<f32>(p.xyx) * 0.1031);
      p3 = p3 + dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
      );
    }
    
    fn fbm(p: vec2<f32>, octaves: i32) -> f32 {
      var value = 0.0;
      var amplitude = 0.5;
      var pos = p;
      let rot = mat2x2<f32>(0.8, 0.6, -0.6, 0.8);
      for (var i = 0; i < 6; i++) {
        if (i >= octaves) { break; }
        value += amplitude * noise(pos);
        pos = rot * pos * 2.0;
        amplitude *= 0.5;
      }
      return value;
    }

    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      
      // Extended neighborhood sampling
      let up = sample(C + vec2<i32>(0, -1));
      let down = sample(C + vec2<i32>(0, 1));
      let left = sample(C + vec2<i32>(-1, 0));
      let right = sample(C + vec2<i32>(1, 0));
      let upLeft = sample(C + vec2<i32>(-1, -1));
      let upRight = sample(C + vec2<i32>(1, -1));
      let downLeft = sample(C + vec2<i32>(-1, 1));
      let downRight = sample(C + vec2<i32>(1, 1));
      
      // State: R = density, G = temperature, BA = velocity
      var density = data.r;
      var temp = data.g;
      var velX = (data.b - 0.5) * 2.0;
      var velY = (data.a - 0.5) * 2.0;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Vorticity Confinement
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let velUp = vec2<f32>((up.b - 0.5) * 2.0, (up.a - 0.5) * 2.0);
      let velDown = vec2<f32>((down.b - 0.5) * 2.0, (down.a - 0.5) * 2.0);
      let velLeft = vec2<f32>((left.b - 0.5) * 2.0, (left.a - 0.5) * 2.0);
      let velRight = vec2<f32>((right.b - 0.5) * 2.0, (right.a - 0.5) * 2.0);
      
      let vorticity = (velRight.y - velLeft.y) - (velUp.x - velDown.x);
      
      // Gradient of vorticity magnitude
      let vortUp = abs((upRight.a - upLeft.a) - (up.a - up.a));
      let vortDown = abs((downRight.a - downLeft.a) - (down.a - down.a));
      let vortLeft = abs((upLeft.a - downLeft.a) - (left.a - left.a));
      let vortRight = abs((upRight.a - downRight.a) - (right.a - right.a));
      
      var vortGrad = vec2<f32>(vortRight - vortLeft, vortUp - vortDown);
      let vortLen = length(vortGrad);
      if (vortLen > 0.0001) {
        vortGrad = vortGrad / vortLen;
        velX += vortGrad.x * vorticity * 0.12;
        velY += vortGrad.y * vorticity * 0.12;
      }
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Temperature-based Buoyancy
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let buoyancy = temp * 0.1 - density * 0.015;
      velY -= buoyancy; // Negative because up is -Y in texture
      
      // Temperature diffusion and cooling
      let avgTemp = (up.g + down.g + left.g + right.g) * 0.25;
      temp = mix(temp, avgTemp, 0.12);
      temp *= 0.995;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Multi-scale Turbulence
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let turbPos = uv * 6.0 + vec2<f32>(u.time * 0.25, u.time * 0.15);
      let curlX = fbm(turbPos + vec2<f32>(0.0, 0.01), 4) - fbm(turbPos - vec2<f32>(0.0, 0.01), 4);
      let curlY = -(fbm(turbPos + vec2<f32>(0.01, 0.0), 4) - fbm(turbPos - vec2<f32>(0.01, 0.0), 4));
      
      velX += curlX * 0.03 * (0.3 + density * 0.5);
      velY += curlY * 0.03 * (0.3 + density * 0.5);
      
      // Small-scale noise
      let microTurb = noise(uv * 30.0 + u.time * 2.0) - 0.5;
      velX += microTurb * 0.01 * density;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Advection (semi-Lagrangian)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let advectUV = uv - vec2<f32>(velX, velY) * 0.01;
      let dims = vec2<f32>(textureDimensions(src));
      let advectCoord = vec2<i32>(clamp(advectUV * dims, vec2<f32>(1.0), dims - 2.0));
      let advected = sample(advectCoord);
      
      density = mix(density, advected.r, 0.85);
      temp = mix(temp, advected.g, 0.85);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Density Diffusion & Dissipation
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let avgDensity = (up.r + down.r + left.r + right.r) * 0.25;
      density = mix(density, avgDensity, 0.06);
      density *= 0.998;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Mouse Emission
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let mousePos = vec2<f32>(u.mouseX, u.mouseY);
      let d = length(uv - mousePos);
      
      if (u.mouseDown > 0.5 && d < 0.1) {
        let falloff = pow(1.0 - d / 0.1, 2.0);
        density += falloff * 0.5;
        temp += falloff * 0.7;
        
        // Add velocity from mouse movement
        let mouseDelta = vec2<f32>(u.mouseX - u.mousePrevX, u.mouseY - u.mousePrevY);
        velX += mouseDelta.x * falloff * 8.0;
        velY -= mouseDelta.y * falloff * 8.0;
      }
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Auto-emitters at Bottom
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      if (uv.y > 0.92) {
        let edge = (uv.y - 0.92) / 0.08;
        let edge2 = edge * edge;
        
        let emitter1 = fbm(vec2<f32>(uv.x * 10.0, u.time * 1.2), 3);
        let emitter2 = noise(vec2<f32>(uv.x * 25.0, u.time * 2.5));
        let emitter3 = sin(uv.x * 15.0 + u.time * 1.5) * 0.5 + 0.5;
        
        let combined = emitter1 * emitter2 * emitter3;
        
        if (combined > 0.2) {
          let intensity = (combined - 0.2) * 5.0 * edge2;
          density += intensity * 0.06;
          temp += intensity * 0.12;
        }
      }
      
      // Velocity damping
      velX *= 0.985;
      velY *= 0.985;
      
      // Clamp and pack
      density = clamp(density, 0.0, 2.0);
      temp = clamp(temp, 0.0, 1.0);
      velX = clamp(velX, -2.0, 2.0);
      velY = clamp(velY, -2.0, 2.0);
      
      textureStore(dst, C, vec4<f32>(density, temp, velX * 0.5 + 0.5, velY * 0.5 + 0.5));
    }
  `,
  
  // Render shader - Volumetric smoke rendering
  /* wgsl */`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let density = data.r;
      let temp = data.g;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Beer-Lambert Light Scattering
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let absorption = 1.8;
      let transmittance = exp(-density * absorption);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Smoke Color with Temperature
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let coolSmoke = vec3<f32>(0.78, 0.80, 0.88);
      let warmSmoke = vec3<f32>(0.92, 0.90, 0.84);
      var smokeColor = mix(coolSmoke, warmSmoke, temp);
      
      // Darker at higher density
      let denseSmoke = vec3<f32>(0.28, 0.29, 0.32);
      smokeColor = mix(smokeColor, denseSmoke, density * 0.35);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Pseudo-lighting from Gradient
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let gradScale = 8.0;
      let lightDir = normalize(vec3<f32>(0.3, 0.8, 0.5));
      
      // Approximate normal from density gradient
      let normalX = -data.b * gradScale;
      let normalY = -data.a * gradScale;
      let normal = normalize(vec3<f32>(normalX, normalY, 1.0));
      
      let diffuse = max(dot(normal, lightDir), 0.0);
      smokeColor *= 0.6 + diffuse * 0.5;
      
      // Rim lighting from below
      let rimDir = normalize(vec3<f32>(0.0, -1.0, 0.3));
      let rim = pow(max(dot(normal, rimDir), 0.0), 2.0);
      smokeColor += vec3<f32>(0.9, 0.85, 0.7) * rim * temp * 0.25;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Background
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let bgTop = vec3<f32>(0.02, 0.025, 0.045);
      let bgBottom = vec3<f32>(0.045, 0.045, 0.055);
      var bg = mix(bgBottom, bgTop, uv.y);
      
      // Vignette
      let vignette = 1.0 - length(uv - 0.5) * 0.3;
      bg *= vignette;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Final Compositing
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      var col = mix(smokeColor, bg, transmittance);
      
      // Atmospheric scattering
      col = mix(col, vec3<f32>(0.32, 0.38, 0.48), (1.0 - transmittance) * 0.06);
      
      // Tone mapping
      col = col / (col + 0.55);
      col = pow(col, vec3<f32>(0.95));
      
      return vec4<f32>(col, 1.0);
    }
  `,
  { canvas: document.getElementById('c'), scale: 0.5 }
);

console.log('%c ğŸ’¨ mushu WebGPU Smoke Ready ', 'background: linear-gradient(90deg, #556, #889); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Click and drag to add smoke!');
</script>
</body>
</html>
