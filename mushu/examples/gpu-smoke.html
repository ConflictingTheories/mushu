<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” WebGPU Smoke Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { gpu } from '../src/gpu/yoGPU.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WebGPU Smoke Simulation
// Volumetric smoke with turbulence and dissipation
// Click and drag to add smoke!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

gpu(
  // Compute shader - Smoke physics
  /* wgsl */`
    fn hash(p: vec2<f32>) -> f32 {
      var p3 = fract(vec3<f32>(p.xyx) * 0.1031);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let s = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), s.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), s.x),
        s.y
      );
    }
    
    fn fbm(p: vec2<f32>) -> f32 {
      var value = 0.0;
      var amplitude = 0.5;
      var pos = p;
      for (var i = 0; i < 4; i++) {
        value += amplitude * noise(pos);
        pos *= 2.0;
        amplitude *= 0.5;
      }
      return value;
    }

    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      
      // Sample neighbors
      let up = sample(C + vec2<i32>(0, -1));    // visual up (lower Y in texture = higher on screen)
      let down = sample(C + vec2<i32>(0, 1));   // visual down
      let left = sample(C + vec2<i32>(-1, 0));
      let right = sample(C + vec2<i32>(1, 0));
      
      // Smoke density in R, velocity in GB
      var density = data.r;
      var velX = data.g - 0.5;
      var velY = data.b - 0.5;
      
      // Turbulence based on position and time
      let turbulence = fbm(uv * 8.0 + u.time * 0.3) - 0.5;
      velX += turbulence * 0.015;
      
      // Buoyancy (smoke rises - in our coordinate system that's -Y direction)
      velY -= density * 0.025;
      
      // Diffusion
      let neighborDensity = (up.r + down.r + left.r + right.r) * 0.25;
      density = mix(density, neighborDensity, 0.12);
      
      // Advection
      let advectPos = uv - vec2<f32>(velX, velY) * 0.015;
      let dims = vec2<f32>(textureDimensions(src));
      let advectCoord = vec2<i32>(clamp(advectPos * dims, vec2<f32>(0.0), dims - 1.0));
      let advected = sample(advectCoord);
      density = mix(density, advected.r, 0.7);
      
      // Dissipation
      density *= 0.994;
      
      // Mouse emission - flip Y to match screen
      let mousePos = vec2<f32>(u.mouseX, u.mouseY);
      let screenUV = vec2<f32>(uv.x, 1.0 - uv.y);
      let distToMouse = length(screenUV - mousePos);
      
      if (u.mouseDown > 0.5 && distToMouse < 0.08) {
        let intensity = pow(1.0 - distToMouse / 0.08, 2.0) * 0.5;
        density += intensity;
      }
      
      // Auto emitters at bottom (high Y in texture = bottom of screen)
      if (uv.y > 0.9) {
        let edge = (uv.y - 0.9) / 0.1;
        let emitterNoise = noise(vec2<f32>(uv.x * 15.0, u.time * 2.0));
        if (emitterNoise > 0.5) {
          density += edge * (emitterNoise - 0.5) * 0.12;
        }
      }
      
      density = clamp(density, 0.0, 1.5);
      
      // Velocity dissipation
      velX *= 0.97;
      velY *= 0.97;
      
      textureStore(dst, C, vec4<f32>(density, velX + 0.5, velY + 0.5, 1.0));
    }
  `,
  
  // Render shader - Smoke visualization
  /* wgsl */`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let density = data.r;
      
      // Smoke color gradient
      let smokeColor = mix(
        vec3<f32>(0.08, 0.08, 0.1),
        vec3<f32>(0.85, 0.87, 0.9),
        density
      );
      
      // Add subtle blue tint
      let tintedColor = mix(
        smokeColor,
        vec3<f32>(0.7, 0.75, 0.85),
        density * 0.25
      );
      
      // Alpha based on density
      let alpha = density * 0.85;
      
      // Dark background gradient
      let bg = mix(
        vec3<f32>(0.015, 0.015, 0.035),
        vec3<f32>(0.04, 0.04, 0.06),
        uv.y
      );
      
      let finalColor = mix(bg, tintedColor, alpha);
      
      return vec4<f32>(finalColor, 1.0);
    }
  `,
  { canvas: document.getElementById('c'), scale: 0.5 }
);

console.log('%c ğŸ’¨ mushu WebGPU Smoke Ready ', 'background: linear-gradient(90deg, #555, #999); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Click and drag to add smoke!');
</script>
</body>
</html>
