<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Plasma - Boilerplate</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
    .info { position: fixed; top: 10px; left: 10px; color: #fff; font: 14px monospace; 
            background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 6px; z-index: 100; }
    .info code { color: #3b82f6; }
  </style>
</head>
<body>
<div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Plasma | Move mouse to interact</div>
<canvas id="canvas"></canvas>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VANILLA WEBGL2 PLASMA - BOILERPLATE EXAMPLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2');

if (!gl) {
  document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
  throw new Error('WebGL2 not supported');
}

const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;

// Classic plasma functions
float plasma1(vec2 p, float t) {
  return sin(p.x * 10.0 + t);
}

float plasma2(vec2 p, float t) {
  return sin(10.0 * (p.x * sin(t * 0.5) + p.y * cos(t * 0.3)) + t);
}

float plasma3(vec2 p, float t) {
  float cx = p.x + 0.5 * sin(t * 0.3);
  float cy = p.y + 0.5 * cos(t * 0.5);
  return sin(sqrt(100.0 * (cx * cx + cy * cy)) + t);
}

float plasma4(vec2 p, float t) {
  float cx = p.x + 0.3 * sin(t * 0.7);
  float cy = p.y + 0.3 * cos(t * 0.4);
  return sin(sqrt(50.0 * (cx * cx + cy * cy)) + t * 2.0);
}

// Better color palette
vec3 palette(float t) {
  vec3 a = vec3(0.5, 0.5, 0.5);
  vec3 b = vec3(0.5, 0.5, 0.5);
  vec3 c = vec3(1.0, 1.0, 1.0);
  vec3 d = vec3(0.0, 0.33, 0.67);
  return a + b * cos(6.28318 * (c * t + d));
}

vec3 palette2(float t) {
  vec3 a = vec3(0.5, 0.5, 0.5);
  vec3 b = vec3(0.5, 0.5, 0.5);
  vec3 c = vec3(1.0, 0.7, 0.4);
  vec3 d = vec3(0.0, 0.15, 0.2);
  return a + b * cos(6.28318 * (c * t + d));
}

void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / min(uResolution.x, uResolution.y);
  float t = uTime * 0.8;
  
  // Mouse influence
  vec2 mouse = (uMouse - 0.5) * 2.0;
  float mouseDist = length(uv - mouse);
  float mouseInfluence = exp(-mouseDist * 3.0);
  
  // Combine plasma patterns
  float v1 = plasma1(uv, t);
  float v2 = plasma2(uv, t * 1.3);
  float v3 = plasma3(uv + mouse * 0.3, t * 0.7);
  float v4 = plasma4(uv - mouse * 0.2, t);
  
  // Mix with mouse interaction
  float plasma = v1 + v2 + v3 + v4;
  plasma = plasma * 0.25;
  plasma += sin(mouseDist * 20.0 - t * 5.0) * mouseInfluence * 0.5;
  
  // Create color layers
  vec3 col1 = palette(plasma + t * 0.1);
  vec3 col2 = palette2(plasma * 0.5 - t * 0.15);
  
  // Blend colors
  vec3 color = mix(col1, col2, sin(plasma * 3.14159) * 0.5 + 0.5);
  
  // Add glow effect near mouse
  color += vec3(0.3, 0.2, 0.5) * mouseInfluence * 0.5;
  
  // Add some contrast
  color = pow(color, vec3(0.9));
  
  // Subtle vignette
  float vignette = 1.0 - length(uv) * 0.3;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

function createProgram(vertSource, fragSource) {
  const vs = createShader(gl.VERTEX_SHADER, vertSource);
  const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program error:', gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const program = createProgram(vertexShaderSource, fragmentShaderSource);

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}

resize();
window.addEventListener('resize', resize);

let mouse = [0.5, 0.5];

canvas.addEventListener('mousemove', e => {
  mouse[0] = e.clientX / window.innerWidth;
  mouse[1] = 1.0 - e.clientY / window.innerHeight;
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length > 0) {
    mouse[0] = e.touches[0].clientX / window.innerWidth;
    mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
  }
}, { passive: false });

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

function render(time) {
  time *= 0.001;
  
  gl.useProgram(program);
  gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);
  gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time);
  gl.uniform2f(gl.getUniformLocation(program, 'uMouse'), mouse[0], mouse[1]);
  
  gl.bindVertexArray(vao);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  
  requestAnimationFrame(render);
}

requestAnimationFrame(render);

// FPS Counter
(function() {
  const fpsDiv = document.createElement('div');
  fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
  document.body.appendChild(fpsDiv);
  let frames = 0, lastTime = performance.now();
  function updateFPS() {
    frames++;
    const now = performance.now();
    if (now - lastTime >= 500) {
      fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
      frames = 0; lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();

console.log('%c ğŸŒˆ Vanilla WebGL2 Plasma ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
</script>
</body>
</html>
