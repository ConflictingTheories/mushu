<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>glsl() â€” Fire Simulation Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// glsl() â€” Fire with Persistent State (ping-pong FBOs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const glsl = (() => {
  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  canvas.style.cssText = 'position:fixed;inset:0;width:100%;height:100%';
  const gl = canvas.getContext('webgl2');

  if (!gl) { alert('WebGL2 not supported'); return; }

  // Enable float textures
  gl.getExtension('EXT_color_buffer_float');

  let width, height;
  const resize = () => {
    const d = devicePixelRatio * 0.5; // Lower res for better perf
    width = Math.floor(innerWidth * d);
    height = Math.floor(innerHeight * d);
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
    initFBOs();
  };

  const mouse = [0, 0, 0, 0]; // x, y, prevX, prevY
  let mouseDown = false;
  addEventListener('mousemove', e => {
    mouse[2] = mouse[0];
    mouse[3] = mouse[1];
    mouse[0] = e.clientX / innerWidth;
    mouse[1] = 1 - e.clientY / innerHeight;
  });
  addEventListener('mousedown', () => mouseDown = true);
  addEventListener('mouseup', () => mouseDown = false);

  // Fullscreen quad
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  // Create FBO with floating point texture
  const createFBO = () => {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.HALF_FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    
    return { tex, fb };
  };

  let fboA, fboB;
  const initFBOs = () => {
    fboA = createFBO();
    fboB = createFBO();
  };

  // Compile shader
  const compile = (fragSrc) => {
    const vs = `#version 300 es
      void main() {
        vec2 positions[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
        gl_Position = vec4(positions[gl_VertexID], 0, 1);
      }`;
    const fs = `#version 300 es
      precision highp float;
      out vec4 O;
      uniform float time;
      uniform vec2 resolution;
      uniform vec4 mouse;
      uniform float mouseDown;
      uniform sampler2D backbuffer;
      ${fragSrc}
      void main() { mainImage(O, gl_FragCoord.xy); }`;

    const p = gl.createProgram();
    const shaderTypes = [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER];
    [vs, fs].forEach((src, i) => {
      const s = gl.createShader(shaderTypes[i]);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(s));
      }
      gl.attachShader(p, s);
    });
    gl.linkProgram(p);
    return p;
  };

  resize();
  addEventListener('resize', resize);

  return (simFrag, renderFrag) => {
    const simProgram = compile(simFrag);
    const renderProgram = compile(renderFrag);

    const loop = (t) => {
      const time = t * 0.001;
      
      // Simulation pass (render to FBO)
      gl.bindFramebuffer(gl.FRAMEBUFFER, fboB.fb);
      gl.viewport(0, 0, width, height);
      gl.useProgram(simProgram);
      gl.uniform1f(gl.getUniformLocation(simProgram, 'time'), time);
      gl.uniform2f(gl.getUniformLocation(simProgram, 'resolution'), width, height);
      gl.uniform4f(gl.getUniformLocation(simProgram, 'mouse'), mouse[0], mouse[1], mouse[2], mouse[3]);
      gl.uniform1f(gl.getUniformLocation(simProgram, 'mouseDown'), mouseDown ? 1.0 : 0.0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fboA.tex);
      gl.uniform1i(gl.getUniformLocation(simProgram, 'backbuffer'), 0);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      // Render pass (to screen)
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, width, height);
      gl.useProgram(renderProgram);
      gl.uniform1f(gl.getUniformLocation(renderProgram, 'time'), time);
      gl.uniform2f(gl.getUniformLocation(renderProgram, 'resolution'), width, height);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fboB.tex);
      gl.uniform1i(gl.getUniformLocation(renderProgram, 'backbuffer'), 0);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      // Swap FBOs
      [fboA, fboB] = [fboB, fboA];

      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIRE SIMULATION â€” Hold & drag mouse to ignite flames!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Simulation shader (runs in FBO, stores: R=fuel, G=heat, B=smoke)
const simShader = `
  // Sample with bounds check
  vec4 sample(vec2 offset) {
    vec2 uv = (gl_FragCoord.xy + offset) / resolution;
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec4(0);
    return texture(backbuffer, uv);
  }

  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    
    vec4 data = sample(vec2(0));
    float fuel = data.r;
    float heat = data.g;
    float smoke = data.b;
    
    // Sample neighbors
    vec4 up = sample(vec2(0, 1));
    vec4 down = sample(vec2(0, -1));
    vec4 left = sample(vec2(-1, 0));
    vec4 right = sample(vec2(1, 0));
    
    // Diffusion (heat spreads)
    float diffusion = 0.12;
    heat += diffusion * (up.g + down.g + left.g + right.g - 4.0 * heat);
    
    // Buoyancy (heat rises)
    heat = mix(heat, down.g, 0.15);
    
    // Wind effect (slight drift right)
    heat = mix(heat, left.g, 0.02);
    
    // Fuel diffuses slower
    fuel += 0.05 * (up.r + down.r + left.r + right.r - 4.0 * fuel);
    fuel = mix(fuel, down.r, 0.08);
    
    // Decay
    fuel *= 0.97;
    heat *= 0.985;
    smoke *= 0.99;
    
    // Mouse ignition
    vec2 mousePos = mouse.xy;
    float d = length(uv - mousePos);
    if (mouseDown > 0.5 && d < 0.08) {
      float intensity = (1.0 - d / 0.08) * 8.0;
      fuel += intensity;
      heat += intensity * 2.0;
    }
    
    // Continuous fire source at bottom
    if (uv.y < 0.08) {
      float pattern = sin(uv.x * 30.0 + time * 3.0) * 0.5 + 0.5;
      pattern *= sin(uv.x * 7.0 - time) * 0.5 + 0.5;
      if (pattern > 0.4) {
        fuel += 1.5 * (1.0 - uv.y / 0.08);
        heat += 3.0 * (1.0 - uv.y / 0.08);
      }
    }
    
    // Combustion: heat consumes fuel, produces smoke
    float burn = min(heat * 0.4, fuel);
    heat += burn * 0.3;
    fuel -= burn;
    smoke += burn * 0.5;
    
    // Smoke rises
    smoke = mix(smoke, down.b, 0.1);
    
    O = vec4(
      clamp(fuel, 0.0, 15.0),
      clamp(heat, 0.0, 15.0),
      clamp(smoke, 0.0, 8.0),
      1.0
    );
  }
`;

// Render shader (converts simulation data to beautiful fire colors)
const renderShader = `
  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec4 data = texture(backbuffer, uv);
    
    float fuel = data.r;
    float heat = data.g;
    float smoke = data.b;
    
    vec3 color = vec3(0);
    
    // Core (white-yellow, very hot)
    color += vec3(1.0, 0.95, 0.8) * pow(heat, 3.5) * 4.0;
    
    // Yellow flames
    color += vec3(1.0, 0.8, 0.2) * pow(heat, 2.0) * 2.5;
    
    // Orange flames
    color += vec3(1.0, 0.4, 0.05) * pow(heat, 1.2) * 1.5;
    
    // Red base
    color += vec3(0.8, 0.1, 0.0) * pow(heat, 0.7) * 0.8;
    
    // Dark smoke overlay
    vec3 smokeColor = vec3(0.02, 0.02, 0.03);
    color = mix(color, smokeColor, clamp(smoke * 0.25, 0.0, 0.8));
    
    // Embers (fuel without heat)
    float embers = fuel * (1.0 - heat * 0.2);
    color += vec3(1.0, 0.3, 0.0) * embers * 0.3;
    
    // Tone mapping
    color = 1.0 - exp(-color * 0.8);
    
    // Slight gamma adjustment
    color = pow(color, vec3(0.9));
    
    O = vec4(color, 1.0);
  }
`;

glsl(simShader, renderShader);

console.log('%c ğŸ”¥ Fire Simulation Demo ', 'background: #ff4500; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold;');
console.log('Hold & drag mouse to ignite flames!');
console.log('Fire burns from bottom automatically.');
</script>
</body>
</html>