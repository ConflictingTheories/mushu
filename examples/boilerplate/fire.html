<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Fire - Boilerplate</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 16px;
      border-radius: 6px;
      z-index: 100;
      pointer-events: none;
    }

    .info code {
      color: #3b82f6;
    }
  </style>
</head>

<body>
  <div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Fire | Move mouse to interact</div>
  <canvas id="canvas"></canvas>
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VANILLA WEBGL2 FIRE - BOILERPLATE EXAMPLE
    // procedural one-shader effect (matches glsl/fire.html logic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
      throw new Error('WebGL2 not supported');
    }

    const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

    const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;

// Noise functions for realistic fire
float hash(vec2 p) {
  vec3 p3 = fract(vec3(p.xyx) * 0.1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
  return mix(
    mix(hash(i), hash(i + vec2(1,0)), f.x),
    mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x),
    f.y
  );
}

float fbm(vec2 p, int octaves) {
  float f = 0.0;
  float amp = 0.5;
  for (int i = 0; i < 8; i++) {
    if (i >= octaves) break;
    f += amp * noise(p);
    p *= 2.0;
    amp *= 0.5;
  }
  return f;
}

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 p = (gl_FragCoord.xy - uResolution * 0.5) / uResolution.y;
  
  // Fire base shape - tapers upward
  float fireShape = 1.0 - uv.y;
  fireShape *= smoothstep(0.5, 0.0, abs(p.x) - 0.15 + uv.y * 0.3);
  
  // Animated turbulence
  float t = uTime;
  vec2 turbUV = vec2(p.x * 3.0, p.y * 2.0 - t * 1.5);
  float turb = fbm(turbUV * 4.0, 5);
  float turb2 = fbm(turbUV * 8.0 + vec2(100.0), 4);
  
  // Distort the fire shape
  float distortedShape = fireShape;
  distortedShape += (turb - 0.5) * 0.8 * fireShape;
  distortedShape += (turb2 - 0.5) * 0.3 * fireShape;
  
  // Add rising wisps
  float wisps = noise(vec2(p.x * 20.0, p.y * 5.0 - t * 3.0));
  wisps *= smoothstep(0.3, 0.0, abs(p.x));
  distortedShape += wisps * 0.3 * (1.0 - uv.y);
  
  // Mouse interaction
  vec2 mouseP = (uMouse - 0.5) * vec2(uResolution.x / uResolution.y, 1.0);
  // Match mushu coordinate system: mouse is 0..1, p is centered
  vec2 m = (uMouse - 0.5);
  m.x *= uResolution.x / uResolution.y;
  
  float mouseDist = length(p - m);
  float mouseInfluence = exp(-mouseDist * 5.0) * 0.5;
  distortedShape += mouseInfluence;
  
  // Fire color gradient (blackbody-inspired)
  float intensity = clamp(distortedShape, 0.0, 1.0);
  
  vec3 color = vec3(0.0);
  
  // White-hot core
  color += vec3(1.0, 1.0, 0.95) * pow(intensity, 4.0) * 3.0;
  // Bright yellow
  color += vec3(1.0, 0.9, 0.5) * pow(intensity, 2.5) * 2.0;
  // Orange
  color += vec3(1.0, 0.5, 0.1) * pow(intensity, 1.5) * 1.5;
  // Red
  color += vec3(0.9, 0.2, 0.05) * pow(intensity, 0.8) * 1.0;
  // Deep red edges
  color += vec3(0.4, 0.05, 0.0) * pow(intensity, 0.4) * 0.5;
  
  // Flickering
  float flicker = noise(vec2(t * 10.0, 0.0)) * 0.1 + 0.95;
  color *= flicker;
  
  // Tone mapping
  color = 1.0 - exp(-color * 0.8);
  color = pow(color, vec3(0.9));
  
  // Subtle vignette
  float vignette = 1.0 - length(uv - 0.5) * 0.3;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(vertSource, fragSource) {
      const vs = createShader(gl.VERTEX_SHADER, vertSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(vertexShaderSource, fragmentShaderSource);

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    let mouse = [0.5, 0.5];

    canvas.addEventListener('mousemove', e => {
      mouse[0] = e.clientX / window.innerWidth;
      mouse[1] = 1.0 - e.clientY / window.innerHeight;
    });
    canvas.addEventListener('touchmove', e => {
      if (e.touches.length > 0) {
        mouse[0] = e.touches[0].clientX / window.innerWidth;
        mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
      }
    }, { passive: true }); // Passive, no preventDefault needed for this simple demo

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    function render(time) {
      time *= 0.001;

      gl.useProgram(program);
      gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time);
      gl.uniform2f(gl.getUniformLocation(program, 'uMouse'), mouse[0], mouse[1]);

      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // FPS Counter
    (function () {
      const fpsDiv = document.createElement('div');
      fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
      document.body.appendChild(fpsDiv);
      let frames = 0, lastTime = performance.now();
      function updateFPS() {
        frames++;
        const now = performance.now();
        if (now - lastTime >= 500) {
          fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
          frames = 0; lastTime = now;
        }
        requestAnimationFrame(updateFPS);
      }
      updateFPS();
    })();

    console.log('%c ğŸ”¥ Vanilla WebGL2 Fire ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
  </script>
</body>

</html>