<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mushu 3D Cube Example</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0f;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import {
      flow,
      cube,
      simulation,
      shader3d,
      camera,
      orbitControls,
      clear,
      mat4,
      fps
    } from '/src/core/index.js';

    // Custom 3D shader
    const vertexShader = /* glsl */`#version 300 es
      precision highp float;
      
      layout(location = 0) in vec3 position;
      layout(location = 1) in vec3 normal;
      layout(location = 2) in vec2 uv;
      
      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 projectionMatrix;
      uniform float time;
      
      out vec3 vNormal;
      out vec3 vPosition;
      out vec2 vUv;
      
      void main() {
        // Wobble the cube
        vec3 pos = position;
        pos += normal * sin(time * 2.0 + position.y * 4.0) * 0.1;
        
        vec4 worldPos = modelMatrix * vec4(pos, 1.0);
        vPosition = worldPos.xyz;
        vNormal = mat3(modelMatrix) * normal;
        vUv = uv;
        
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `;

    const fragmentShader = /* glsl */`#version 300 es
      precision highp float;
      
      in vec3 vNormal;
      in vec3 vPosition;
      in vec2 vUv;
      
      uniform float time;
      uniform vec3 cameraPosition;
      
      out vec4 fragColor;
      
      void main() {
        vec3 N = normalize(vNormal);
        vec3 V = normalize(cameraPosition - vPosition);
        
        // Rim lighting
        float rim = 1.0 - max(dot(N, V), 0.0);
        rim = pow(rim, 3.0);
        
        // Color based on normal
        vec3 baseColor = N * 0.5 + 0.5;
        
        // Add time-based hue shift
        baseColor = mix(baseColor, vec3(
          sin(time + vUv.x * 6.28) * 0.5 + 0.5,
          sin(time * 1.3 + vUv.y * 6.28) * 0.5 + 0.5,
          cos(time * 0.7) * 0.5 + 0.5
        ), 0.5);
        
        // Simple lighting
        vec3 lightDir = normalize(vec3(1, 1, 1));
        float diff = max(dot(N, lightDir), 0.0);
        vec3 color = baseColor * (0.3 + 0.7 * diff);
        
        // Add rim
        color += vec3(0.3, 0.5, 1.0) * rim;
        
        fragColor = vec4(color, 1.0);
      }
    `;

    // Create the camera
    const cam = camera({
      position: [3, 2, 3],
      target: [0, 0, 0],
      fov: 60
    });

    // Create orbit controls
    const controls = orbitControls(cam);

    // Rotation state
    let rotationY = 0;
    const modelMatrix = mat4.create();

    const plasma3dMushu =
      flow('#canvas')
        .use(cam)
        .use(controls)
        .use(fps())
        .use(shader3d(vertexShader, fragmentShader, {
          depthTest: true,
          cullFace: 'BACK'
        }));

    // Start the render loop
    plasma3dMushu
      .use({
        render(ctx) {
          // Rotate the model
          rotationY += ctx.delta * 0.7;
          mat4.rotateY(modelMatrix, rotationY);

          // Update shader uniform
          const shader = ctx.state.shader3d;
          if (shader) {
            shader.setModelMatrix(modelMatrix);
          }
        }
      })
      .use(cube({ size: 1.5 }));

    rotationY = 0;

    plasma3dMushu
      .use({
        render(ctx) {
          // Rotate the model ccw
          rotationY += ctx.delta * -0.2;
          mat4.rotateY(modelMatrix, rotationY);

          // Update shader uniform
          const shader = ctx.state.shader3d;
          if (shader) {
            shader.setModelMatrix(modelMatrix);
          }
        }
      })
      .use(cube({ size: 2.5 }))
      .go();
  </script>
</body>

</html>