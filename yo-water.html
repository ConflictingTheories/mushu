<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>yo() â€” Simplified Water Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { yo, shader, quad, fps } from './yo.js?v=2';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Water caustics in ~60 lines of shader code
// The framework handles everything else
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

yo(document.getElementById('c'))
  .use(shader(`
    const vec3 SKY = vec3(0.4, 0.6, 0.9);
    const vec3 WATER = vec3(0.02, 0.12, 0.22);

    float hash(vec3 p) {
      p = fract(p * 0.3183099 + 0.1);
      p *= 17.0;
      return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
    }

    float noise(vec3 x) {
      vec3 i = floor(x), f = fract(x);
      f = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
    }

    float fbm(vec3 p) {
      float f = 0.0, amp = 0.5;
      for (int i = 0; i < 5; i++) { f += amp * noise(p); p *= 2.03; amp *= 0.49; }
      return f;
    }

    float waterHeight(vec2 p, float t) {
      float h = fbm(vec3(p * 3.0, t * 0.4)) * 0.1;
      h += 0.3 * noise(vec3(p * 8.0, t * 1.5)) * 0.1;
      vec2 m = (mouse * 0.5 + 0.5) - 0.5;
      float d = length(p - m);
      h += sin(d * 25.0 - t * 8.0) * exp(-d * 4.0) * 0.15 * (mouseDown > 0.5 ? 3.0 : 1.0);
      return h;
    }

    vec3 waterNormal(vec2 p, float t) {
      float eps = 0.01;
      float h = waterHeight(p, t);
      return normalize(vec3(h - waterHeight(p + vec2(eps, 0), t), eps * 8.0, h - waterHeight(p + vec2(0, eps), t)));
    }

    float caustics(vec2 p, float t) {
      float c = 0.0;
      vec2 uv = p * 6.0;
      for (int i = 1; i < 8; i++) {
        float s = float(i);
        vec2 q = uv * s + vec2(sin(t * 0.3 * s), cos(t * 0.2 * s)) * 0.5;
        float wave = sin(q.x + sin(q.y + t * s * 0.1)) + sin(q.y + cos(q.x - t * s * 0.15));
        c += abs(wave) / s;
      }
      return pow(c * 0.15, 2.5);
    }

    void mainImage(out vec4 O, vec2 C) {
      vec2 uv = (C - resolution.xy * 0.5) / resolution.y;
      float t = time;
      
      vec3 n = waterNormal(uv, t);
      float h = waterHeight(uv, t);
      vec3 view = normalize(vec3(uv, 1.5));
      vec3 light = normalize(vec3(0.5, 0.8, 0.5));
      vec3 refl = reflect(-view, n);
      
      float fresnel = pow(1.0 - max(0.0, dot(view, n)), 4.0);
      vec3 skyRefl = SKY + vec3(0.4, 0.3, 0.2) * pow(max(0.0, refl.y), 3.0);
      skyRefl += vec3(1.0, 0.9, 0.7) * pow(max(0.0, dot(refl, light)), 64.0);
      
      float depth = 0.5 - uv.y + h;
      vec3 refr = mix(WATER, vec3(0.01, 0.05, 0.1), smoothstep(0.0, 1.0, depth));
      refr += vec3(0.8, 0.9, 1.0) * caustics(uv + n.xz * 0.1, t) * exp(-depth * 3.0);
      
      vec3 col = mix(refr, skyRefl, fresnel * 0.7);
      col = mix(col, vec3(0.95, 0.98, 1.0), smoothstep(0.08, 0.12, h) * 0.6);
      col += vec3(1.0, 0.95, 0.9) * pow(max(0.0, dot(n, normalize(light + view))), 128.0);
      
      col = col / (col + 1.0);
      O = vec4(pow(col, vec3(0.85)), 1.0);
    }
  `))
  .use(quad())
  .use(fps())
  .go();

console.log('%c ğŸŒŠ yo() Water Ready ', 'background: #0077be; color: white; padding: 4px 8px; border-radius: 4px;');
</script>
</body>
</html>