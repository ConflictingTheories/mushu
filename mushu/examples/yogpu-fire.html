<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” YOGPU Fire Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { yoGPU } from '../src/gpu/yoGPU.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YOGPU Fire Simulation (WebGPU Fluent API)
// 
// Uses the yoGPU() fluent builder for WebGPU compute+render pipeline
// Features:
//   â€¢ Multi-octave turbulence
//   â€¢ Combustion physics with fuel consumption
//   â€¢ Ember particle system
//   â€¢ Blackbody radiation coloring
// 
// Hold & drag mouse to ignite flames!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

yoGPU(document.getElementById('c'))
  .scale(0.5)
  .simulate(`
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Noise Functions
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    fn hash(p: vec2<f32>) -> f32 {
      var p3 = fract(vec3<f32>(p.xyx) * 0.1031);
      p3 = p3 + dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
      );
    }
    
    fn fbm(p: vec2<f32>, octaves: i32) -> f32 {
      var value = 0.0;
      var amplitude = 0.5;
      var pos = p;
      let rot = mat2x2<f32>(0.8, 0.6, -0.6, 0.8);
      for (var i = 0; i < 5; i++) {
        if (i >= octaves) { break; }
        value += amplitude * noise(pos);
        pos = rot * pos * 2.0;
        amplitude *= 0.5;
      }
      return value;
    }

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
      let dims = vec2<i32>(textureDimensions(src));
      let C = vec2<i32>(id.xy);
      if (C.x >= dims.x || C.y >= dims.y) { return; }
      
      let uv = vec2<f32>(C) / vec2<f32>(dims);
      var data = sample(C);
      var fuel = data.r;
      var heat = data.g;
      var smoke = data.b;
      var embers = data.a;
      
      // Sample neighbors using helper
      let up = sampleOffset(C, vec2<i32>(0, -1));
      let down = sampleOffset(C, vec2<i32>(0, 1));
      let left = sampleOffset(C, vec2<i32>(-1, 0));
      let right = sampleOffset(C, vec2<i32>(1, 0));
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Turbulence
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let turbPos = vec2<f32>(uv.x * 12.0, uv.y * 6.0 + u.time * 2.5);
      let turb = fbm(turbPos, 4) - 0.5;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Heat Dynamics
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      heat += 0.1 * (up.g + down.g + left.g + right.g - 4.0 * heat);
      heat = mix(heat, down.g, 0.22 + heat * 0.08);
      heat = mix(heat, mix(left.g, right.g, 0.5), abs(turb) * 0.18);
      
      // Fuel transport
      fuel += 0.03 * (up.r + down.r + left.r + right.r - 4.0 * fuel);
      fuel = mix(fuel, down.r, 0.05);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Combustion
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      if (heat > 0.25 && fuel > 0.01) {
        let burn = min(fuel, (heat - 0.25) * 0.7);
        heat += burn * 1.1;
        fuel -= burn;
        smoke += burn * 0.35;
        
        if (burn > 0.12 && hash(uv + u.time) > 0.96) {
          embers += 0.25;
        }
      }
      
      // Ember dynamics
      embers = mix(embers, down.a, 0.3);
      embers *= 0.97;
      
      // Smoke rises
      smoke = mix(smoke, down.b, 0.1);
      smoke *= 0.996;
      
      // Decay
      fuel *= 0.99;
      heat *= 0.985;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Mouse Ignition
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let mouse = vec2<f32>(u.mouseX, u.mouseY);
      let d = length(uv - mouse);
      
      if (u.mouseDown > 0.5 && d < 0.1) {
        let intensity = pow(1.0 - d / 0.1, 2.0) * 12.0;
        fuel += intensity;
        heat += intensity * 2.2;
      }
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Fire Source
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      if (uv.y > 0.88) {
        let edge = (uv.y - 0.88) / 0.12;
        let p1 = sin(uv.x * 25.0 + u.time * 4.5) * 0.5 + 0.5;
        let p2 = sin(uv.x * 10.0 - u.time * 2.0) * 0.5 + 0.5;
        let p3 = fbm(vec2<f32>(uv.x * 35.0, u.time * 7.0), 3);
        let pattern = p1 * p2 * (0.4 + p3 * 0.6);
        
        if (pattern > 0.2) {
          let intensity = pattern * edge * edge * 2.2;
          fuel += intensity * 1.3;
          heat += intensity * 2.8;
        }
      }
      
      textureStore(dst, C, vec4<f32>(
        clamp(fuel, 0.0, 25.0),
        clamp(heat, 0.0, 25.0),
        clamp(smoke, 0.0, 15.0),
        clamp(embers, 0.0, 2.0)
      ));
    }
  `)
  .display(`
    @fragment fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
      let data = textureSample(simTex, texSampler, uv);
      let fuel = data.r;
      let heat = data.g;
      let smoke = data.b;
      let embers = data.a;
      
      var col = vec3<f32>(0.0);
      
      // Blackbody color ramp
      col += vec3<f32>(1.0, 1.0, 0.97) * pow(heat, 4.5) * 4.5;
      col += vec3<f32>(1.0, 0.9, 0.65) * pow(heat, 3.5) * 2.8;
      col += vec3<f32>(1.0, 0.6, 0.18) * pow(heat, 2.2) * 2.2;
      col += vec3<f32>(1.0, 0.32, 0.03) * pow(heat, 1.4) * 1.8;
      col += vec3<f32>(0.75, 0.12, 0.0) * pow(heat, 0.75) * 0.9;
      
      // Embers
      col += vec3<f32>(1.0, 0.5, 0.15) * embers * 1.8;
      
      // Fuel glow
      col += vec3<f32>(1.0, 0.4, 0.1) * fuel * (1.0 - heat * 0.15) * 0.2;
      
      // Smoke overlay
      let smokeColor = vec3<f32>(0.025, 0.025, 0.03);
      let smokeAlpha = 1.0 - exp(-smoke * 0.28);
      col = mix(col, smokeColor, smokeAlpha * 0.82);
      
      // Tone mapping
      col = col * (col + 0.15) / (col * 1.1 + 0.5);
      col = pow(col, vec3<f32>(0.92));
      
      return vec4<f32>(col, 1.0);
    }
  `)
  .go();

console.log('%c ğŸ”¥ mushu YOGPU Fire Ready ', 'background: linear-gradient(90deg, #ff4400, #ff8800); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Hold and drag mouse to ignite flames!');
</script>
</body>
</html>
