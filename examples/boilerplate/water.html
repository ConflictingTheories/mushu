<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Water - Boilerplate</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 16px;
      border-radius: 6px;
      z-index: 100;
      pointer-events: none;
    }

    .info code {
      color: #3b82f6;
    }
  </style>
</head>

<body>
  <div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Water | Move mouse to interact</div>
  <canvas id="canvas"></canvas>
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VANILLA WEBGL2 WATER - BOILERPLATE EXAMPLE
    // procedural one-shader effect (matches glsl/water.html logic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
      throw new Error('WebGL2 not supported');
    }

    const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

    const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(hash(i), hash(i + vec2(1,0)), f.x),
    mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x),
    f.y
  );
}

float fbm(vec2 p) {
  float f = 0.0;
  float amp = 0.5;
  mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);
  for (int i = 0; i < 5; i++) {
    f += amp * noise(p);
    p = rot * p * 2.0;
    amp *= 0.5;
  }
  return f;
}

// Gerstner wave
vec3 gerstnerWave(vec2 p, vec2 dir, float steepness, float wavelength, float t) {
  float k = 6.28318 / wavelength;
  float c = sqrt(9.8 / k);
  float a = steepness / k;
  float f = k * (dot(dir, p) - c * t);
  return vec3(dir.x * a * cos(f), a * sin(f), dir.y * a * cos(f));
}

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 p = (gl_FragCoord.xy - uResolution * 0.5) / uResolution.y;
  float t = uTime * 0.5;
  
  // Mouse influence
  vec2 mouseP = (uMouse - 0.5) * vec2(uResolution.x / uResolution.y, 1.0);
  vec2 m = (uMouse - 0.5);
  m.x *= uResolution.x / uResolution.y;
  float mouseDist = length(p - m);
  
  // Combine multiple Gerstner waves
  vec3 wave = vec3(0.0);
  wave += gerstnerWave(p * 5.0, normalize(vec2(1.0, 0.3)), 0.15, 0.8, t);
  wave += gerstnerWave(p * 5.0, normalize(vec2(-0.5, 0.8)), 0.12, 0.6, t * 1.1);
  wave += gerstnerWave(p * 8.0, normalize(vec2(0.7, -0.5)), 0.08, 0.4, t * 1.3);
  wave += gerstnerWave(p * 12.0, normalize(vec2(-0.3, -0.7)), 0.05, 0.25, t * 1.5);
  
  // Add turbulent detail
  float detail = fbm(p * 8.0 + t * 0.2) * 0.1;
  wave.y += detail;
  
  // Mouse creates local disturbance
  float mouseRipple = sin(mouseDist * 40.0 - t * 8.0) * exp(-mouseDist * 6.0) * 0.15;
  wave.y += mouseRipple;
  
  // Calculate normals from wave displacement
  float eps = 0.01;
  vec3 wave_dx = gerstnerWave((p + vec2(eps, 0)) * 5.0, normalize(vec2(1.0, 0.3)), 0.15, 0.8, t)
               + gerstnerWave((p + vec2(eps, 0)) * 5.0, normalize(vec2(-0.5, 0.8)), 0.12, 0.6, t * 1.1);
  vec3 wave_dy = gerstnerWave((p + vec2(0, eps)) * 5.0, normalize(vec2(1.0, 0.3)), 0.15, 0.8, t)
               + gerstnerWave((p + vec2(0, eps)) * 5.0, normalize(vec2(-0.5, 0.8)), 0.12, 0.6, t * 1.1);
  
  vec3 normal = normalize(vec3(
    (wave.y - wave_dx.y) * 10.0,
    1.0,
    (wave.y - wave_dy.y) * 10.0
  ));
  
  // View and light setup
  vec3 viewDir = vec3(0.0, 1.0, 0.0);
  vec3 lightDir = normalize(vec3(0.3, 0.8, 0.5));
  
  // Fresnel
  float fresnel = pow(1.0 - max(0.0, dot(viewDir, normal)), 4.0);
  fresnel = 0.15 + 0.85 * fresnel;
  
  // Reflection
  vec3 reflDir = reflect(-viewDir, normal);
  float skyGradient = reflDir.y * 0.5 + 0.5;
  vec3 skyColor = mix(
    vec3(0.7, 0.8, 0.95),
    vec3(0.4, 0.6, 0.9),
    pow(skyGradient, 0.6)
  );
  
  // Sun specular
  float sunSpec = pow(max(0.0, dot(reflDir, lightDir)), 200.0);
  vec3 sunColor = vec3(1.0, 0.95, 0.9) * sunSpec * 4.0;
  
  // Water colors
  vec3 waterDeep = vec3(0.01, 0.05, 0.12);
  vec3 waterShallow = vec3(0.08, 0.2, 0.3);
  float depth = 0.5 + wave.y * 3.0;
  vec3 waterColor = mix(waterDeep, waterShallow, clamp(depth, 0.0, 1.0));
  
  // Caustics
  float caustic1 = sin((p.x + normal.x) * 30.0 + t * 2.0) * sin((p.y + normal.z) * 30.0 + t * 1.5);
  float caustic2 = sin((p.x - normal.x) * 20.0 - t * 1.5) * sin((p.y - normal.z) * 25.0 + t * 2.0);
  float caustics = pow((caustic1 + caustic2) * 0.5 + 0.5, 4.0) * 0.2;
  waterColor += vec3(0.2, 0.3, 0.4) * caustics;
  
  // Combine
  vec3 color = mix(waterColor, skyColor, fresnel * 0.7);
  color += sunColor;
  
  // Foam on wave crests
  float foam = smoothstep(0.08, 0.15, wave.y);
  color = mix(color, vec3(0.95, 0.98, 1.0), foam * 0.5);
  
  // Subsurface scattering
  float sss = pow(max(0.0, dot(lightDir, -normal)), 2.0) * 0.1;
  color += vec3(0.1, 0.3, 0.4) * sss;
  
  // Tone mapping
  color = 1.0 - exp(-color * 1.2);
  color = pow(color, vec3(0.95));
  
  // Vignette
  float vignette = 1.0 - length(uv - 0.5) * 0.25;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(vertSource, fragSource) {
      const vs = createShader(gl.VERTEX_SHADER, vertSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(vertexShaderSource, fragmentShaderSource);

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    let mouse = [0.5, 0.5];

    canvas.addEventListener('mousemove', e => {
      mouse[0] = e.clientX / window.innerWidth;
      mouse[1] = 1.0 - e.clientY / window.innerHeight;
    });
    canvas.addEventListener('touchmove', e => {
      if (e.touches.length > 0) {
        mouse[0] = e.touches[0].clientX / window.innerWidth;
        mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
      }
    }, { passive: true });

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    function render(time) {
      time *= 0.001;

      gl.useProgram(program);
      gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time);
      gl.uniform2f(gl.getUniformLocation(program, 'uMouse'), mouse[0], mouse[1]);

      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // FPS Counter
    (function () {
      const fpsDiv = document.createElement('div');
      fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
      document.body.appendChild(fpsDiv);
      let frames = 0, lastTime = performance.now();
      function updateFPS() {
        frames++;
        const now = performance.now();
        if (now - lastTime >= 500) {
          fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
          frames = 0; lastTime = now;
        }
        requestAnimationFrame(updateFPS);
      }
      updateFPS();
    })();

    console.log('%c ğŸŒŠ Vanilla WebGL2 Water ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
  </script>
</body>

</html>