<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” yo() Water Demo</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; }
    .info { position: fixed; top: 10px; left: 10px; color: #fff; font: 14px monospace; 
            background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 6px; z-index: 100; }
    .info code { color: #00bbdd; }
  </style>
</head>
<body>
<div class="info">ğŸŒŠ <code>yo()</code> Water | Move mouse to interact</div>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { glsl } from '../src/core/yo.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YO Water - Using glsl() helper for procedural Gerstner waves
// Matches the GLSL water.html demo exactly
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

glsl(`
  float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
  }
  
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    return mix(
      mix(hash(i), hash(i + vec2(1,0)), f.x),
      mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x),
      f.y
    );
  }
  
  float fbm(vec2 p) {
    float f = 0.0;
    float amp = 0.5;
    mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);
    for (int i = 0; i < 5; i++) {
      f += amp * noise(p);
      p = rot * p * 2.0;
      amp *= 0.5;
    }
    return f;
  }
  
  // Gerstner wave
  vec3 gerstnerWave(vec2 p, vec2 dir, float steepness, float wavelength, float t) {
    float k = 6.28318 / wavelength;
    float c = sqrt(9.8 / k);
    float a = steepness / k;
    float f = k * (dot(dir, p) - c * t);
    return vec3(dir.x * a * cos(f), a * sin(f), dir.y * a * cos(f));
  }
  
  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec2 p = (C - resolution * 0.5) / resolution.y;
    float t = time * 0.5;
    
    // Mouse influence
    vec2 mouseP = mouse - 0.5;
    mouseP.x *= resolution.x / resolution.y;
    float mouseDist = length(p - mouseP);
    
    // Combine multiple Gerstner waves
    vec3 wave = vec3(0.0);
    wave += gerstnerWave(p * 5.0, normalize(vec2(1.0, 0.3)), 0.15, 0.8, t);
    wave += gerstnerWave(p * 5.0, normalize(vec2(-0.5, 0.8)), 0.12, 0.6, t * 1.1);
    wave += gerstnerWave(p * 8.0, normalize(vec2(0.7, -0.5)), 0.08, 0.4, t * 1.3);
    wave += gerstnerWave(p * 12.0, normalize(vec2(-0.3, -0.7)), 0.05, 0.25, t * 1.5);
    
    // Add turbulent detail
    float detail = fbm(p * 8.0 + t * 0.2) * 0.1;
    wave.y += detail;
    
    // Mouse creates local disturbance
    float mouseRipple = sin(mouseDist * 40.0 - t * 8.0) * exp(-mouseDist * 6.0) * 0.15;
    wave.y += mouseRipple;
    
    // Calculate normals from wave displacement
    float eps = 0.01;
    vec3 wave_dx = gerstnerWave((p + vec2(eps, 0)) * 5.0, normalize(vec2(1.0, 0.3)), 0.15, 0.8, t)
                 + gerstnerWave((p + vec2(eps, 0)) * 5.0, normalize(vec2(-0.5, 0.8)), 0.12, 0.6, t * 1.1);
    vec3 wave_dy = gerstnerWave((p + vec2(0, eps)) * 5.0, normalize(vec2(1.0, 0.3)), 0.15, 0.8, t)
                 + gerstnerWave((p + vec2(0, eps)) * 5.0, normalize(vec2(-0.5, 0.8)), 0.12, 0.6, t * 1.1);
    
    vec3 normal = normalize(vec3(
      (wave.y - wave_dx.y) * 10.0,
      1.0,
      (wave.y - wave_dy.y) * 10.0
    ));
    
    // View and light setup
    vec3 viewDir = vec3(0.0, 1.0, 0.0);
    vec3 lightDir = normalize(vec3(0.3, 0.8, 0.5));
    
    // Fresnel
    float fresnel = pow(1.0 - max(0.0, dot(viewDir, normal)), 4.0);
    fresnel = 0.15 + 0.85 * fresnel;
    
    // Reflection
    vec3 reflDir = reflect(-viewDir, normal);
    float skyGradient = reflDir.y * 0.5 + 0.5;
    vec3 skyColor = mix(
      vec3(0.7, 0.8, 0.95),
      vec3(0.4, 0.6, 0.9),
      pow(skyGradient, 0.6)
    );
    
    // Sun specular
    float sunSpec = pow(max(0.0, dot(reflDir, lightDir)), 200.0);
    vec3 sunColor = vec3(1.0, 0.95, 0.9) * sunSpec * 4.0;
    
    // Water colors
    vec3 waterDeep = vec3(0.01, 0.05, 0.12);
    vec3 waterShallow = vec3(0.08, 0.2, 0.3);
    float depth = 0.5 + wave.y * 3.0;
    vec3 waterColor = mix(waterDeep, waterShallow, clamp(depth, 0.0, 1.0));
    
    // Caustics
    float caustic1 = sin((p.x + normal.x) * 30.0 + t * 2.0) * sin((p.y + normal.z) * 30.0 + t * 1.5);
    float caustic2 = sin((p.x - normal.x) * 20.0 - t * 1.5) * sin((p.y - normal.z) * 25.0 + t * 2.0);
    float caustics = pow((caustic1 + caustic2) * 0.5 + 0.5, 4.0) * 0.2;
    waterColor += vec3(0.2, 0.3, 0.4) * caustics;
    
    // Combine
    vec3 color = mix(waterColor, skyColor, fresnel * 0.7);
    color += sunColor;
    
    // Foam on wave crests
    float foam = smoothstep(0.08, 0.15, wave.y);
    color = mix(color, vec3(0.95, 0.98, 1.0), foam * 0.5);
    
    // Subsurface scattering
    float sss = pow(max(0.0, dot(lightDir, -normal)), 2.0) * 0.1;
    color += vec3(0.1, 0.3, 0.4) * sss;
    
    // Tone mapping
    color = 1.0 - exp(-color * 1.2);
    color = pow(color, vec3(0.95));
    
    // Vignette
    float vignette = 1.0 - length(uv - 0.5) * 0.25;
    color *= vignette;
    
    O = vec4(color, 1.0);
  }
`, document.getElementById('c'));

// FPS Counter
(function() {
  const fpsDiv = document.createElement('div');
  fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
  document.body.appendChild(fpsDiv);
  let frames = 0, lastTime = performance.now();
  function updateFPS() {
    frames++;
    const now = performance.now();
    if (now - lastTime >= 500) {
      fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
      frames = 0; lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();

console.log('%c ğŸŒŠ yo() Water ', 'background: linear-gradient(90deg, #0066aa, #00bbdd); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Procedural Gerstner wave ocean using glsl() helper');
</script>
</body>
</html>
