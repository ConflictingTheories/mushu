<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>gpu() â€” WebGPU Smoke Simulation</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// gpu() â€” WebGPU Volumetric Smoke Simulation
// Hold & drag mouse to blow wind through the smoke!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const gpu = async (computeCode, renderCode) => {
  if (!navigator.gpu) {
    document.body.innerHTML = `
      <div style="color:#fff;font-family:system-ui;padding:40px;text-align:center">
        <h1>WebGPU Not Supported</h1>
        <p>Use Chrome 129+ or Edge with WebGPU enabled.</p>
      </div>`;
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();

  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  canvas.style.cssText = 'position:fixed;inset:0;width:100%;height:100%';

  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();

  let width, height;

  const resize = () => {
    const d = devicePixelRatio * 0.5;
    width = Math.floor(innerWidth * d);
    height = Math.floor(innerHeight * d);
    canvas.width = width;
    canvas.height = height;
    context.configure({ device, format, alphaMode: 'premultiplied' });
  };
  resize();
  addEventListener('resize', resize);

  const mouse = [0, 0, 0, 0];
  let mouseDown = false;
  addEventListener('mousemove', e => {
    mouse[2] = mouse[0];
    mouse[3] = mouse[1];
    mouse[0] = e.clientX / innerWidth;
    mouse[1] = e.clientY / innerHeight;
  });
  addEventListener('mousedown', () => mouseDown = true);
  addEventListener('mouseup', () => mouseDown = false);

  const createStateTexture = () => device.createTexture({
    size: [width, height],
    format: 'rgba16float',
    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
  });

  let stateA = createStateTexture();
  let stateB = createStateTexture();

  const uniformBuffer = device.createBuffer({
    size: 48,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  const computeModule = device.createShaderModule({
    code: /* wgsl */`
      struct Uniforms {
        time: f32,
        mouseX: f32,
        mouseY: f32,
        mouseDown: f32,
        prevMouseX: f32,
        prevMouseY: f32,
        width: f32,
        height: f32,
      }
      
      @group(0) @binding(0) var<uniform> u: Uniforms;
      @group(0) @binding(1) var src: texture_storage_2d<rgba16float, read>;
      @group(0) @binding(2) var dst: texture_storage_2d<rgba16float, write>;

      fn sample(c: vec2<i32>) -> vec4<f32> {
        let dims = vec2<i32>(textureDimensions(src));
        let p = clamp(c, vec2<i32>(0), dims - vec2<i32>(1));
        return textureLoad(src, p);
      }

      ${computeCode}

      @compute @workgroup_size(16, 16)
      fn main(@builtin(global_invocation_id) id: vec3<u32>) {
        let C = vec2<i32>(id.xy);
        let dims = textureDimensions(src);
        if (u32(C.x) >= dims.x || u32(C.y) >= dims.y) { return; }
        let uv = vec2<f32>(C) / vec2<f32>(dims);
        compute(C, uv);
      }
    `
  });

  const computeBindGroupLayout = device.createBindGroupLayout({
    entries: [
      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
      { binding: 1, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: 'read-only', format: 'rgba16float' } },
      { binding: 2, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: 'write-only', format: 'rgba16float' } }
    ]
  });

  const computePipeline = device.createComputePipeline({
    layout: device.createPipelineLayout({ bindGroupLayouts: [computeBindGroupLayout] }),
    compute: { module: computeModule, entryPoint: 'main' }
  });

  const renderModule = device.createShaderModule({
    code: /* wgsl */`
      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) uv: vec2<f32>,
      }

      @vertex
      fn vs(@builtin(vertex_index) i: u32) -> VertexOutput {
        var pos = array<vec2<f32>, 3>(
          vec2<f32>(-1.0, -1.0),
          vec2<f32>(3.0, -1.0),
          vec2<f32>(-1.0, 3.0)
        );
        var output: VertexOutput;
        output.position = vec4<f32>(pos[i], 0.0, 1.0);
        output.uv = pos[i] * 0.5 + 0.5;
        return output;
      }

      @group(0) @binding(0) var tex: texture_2d<f32>;
      @group(0) @binding(1) var samp: sampler;

      ${renderCode}

      @fragment
      fn fs(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
        let data = textureSample(tex, samp, uv);
        return render(data, uv);
      }
    `
  });

  const renderPipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: { module: renderModule, entryPoint: 'vs' },
    fragment: { module: renderModule, entryPoint: 'fs', targets: [{ format }] },
    primitive: { topology: 'triangle-list' }
  });

  const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });

  const loop = () => {
    const time = performance.now() * 0.001;

    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([
      time, mouse[0], mouse[1], mouseDown ? 1.0 : 0.0,
      mouse[2], mouse[3], width, height
    ]));

    const encoder = device.createCommandEncoder();

    const computePass = encoder.beginComputePass();
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, device.createBindGroup({
      layout: computeBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: stateA.createView() },
        { binding: 2, resource: stateB.createView() }
      ]
    }));
    computePass.dispatchWorkgroups(Math.ceil(width / 16), Math.ceil(height / 16));
    computePass.end();

    const renderPass = encoder.beginRenderPass({
      colorAttachments: [{
        view: context.getCurrentTexture().createView(),
        clearValue: [0.02, 0.02, 0.05, 1],
        loadOp: 'clear',
        storeOp: 'store'
      }]
    });
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, device.createBindGroup({
      layout: renderPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: stateB.createView() },
        { binding: 1, resource: sampler }
      ]
    }));
    renderPass.draw(3);
    renderPass.end();

    device.queue.submit([encoder.finish()]);
    [stateA, stateB] = [stateB, stateA];
    requestAnimationFrame(loop);
  };
  loop();

  console.log('%c ğŸ’¨ WebGPU Smoke Ready ', 'background: #4a5568; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold;');
  console.log('Hold & drag mouse to blow wind through the smoke!');
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SMOKE SIMULATION
// Channels: R=density, G=temperature, B=velocity.x, A=velocity.y
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

gpu(
  // Compute shader (smoke physics)
  /* wgsl */`
    fn hash(p: vec2<f32>) -> f32 {
      return fract(sin(dot(p, vec2<f32>(12.9898, 78.233))) * 43758.5453);
    }

    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      var density = data.r;
      var temp = data.g;
      var vx = data.b;
      var vy = data.a;
      
      // Sample neighbors - texture +Y is visual down
      let up = sample(C + vec2<i32>(0, -1));    // visual up
      let down = sample(C + vec2<i32>(0, 1));   // visual down
      let left = sample(C - vec2<i32>(1, 0));
      let right = sample(C + vec2<i32>(1, 0));
      
      let dt = 0.016;
      
      // Mouse force (wind) - flip Y
      let mouse = vec2<f32>(u.mouseX, 1.0 - u.mouseY);
      let prevMouse = vec2<f32>(u.prevMouseX, 1.0 - u.prevMouseY);
      let mouseDist = length(uv - mouse);
      
      if (u.mouseDown > 0.5 && mouseDist < 0.12) {
        let dir = normalize(mouse - prevMouse + vec2<f32>(0.001, 0.001));
        let speed = length(mouse - prevMouse) * 100.0;
        let falloff = 1.0 - mouseDist / 0.12;
        vx += dir.x * speed * falloff;
        vy -= dir.y * speed * falloff;  // flip for texture coords
        density += falloff * 2.0;
        temp += falloff * 1.5;
      }
      
      // Buoyancy (hot air rises - moves toward -Y in texture space)
      vy -= temp * 0.6 * dt;
      
      // Vorticity confinement (creates curling)
      let curlL = left.a;
      let curlR = right.a;
      let curlT = up.b;
      let curlB = down.b;
      let curl = (curlR - curlL) - (curlT - curlB);
      let vorticity = 0.1;
      vx += curl * vorticity * sign(curl);
      
      // Velocity diffusion & damping
      let velDiff = 0.1;
      vx += velDiff * (left.b + right.b - 2.0 * vx);
      vy += velDiff * (up.a + down.a - 2.0 * vy);
      vx *= 0.98;
      vy *= 0.98;
      
      // Advection (move density along velocity)
      let vel = vec2<f32>(vx, vy);
      let advectPos = vec2<f32>(C) - vel * dt * 60.0;
      let advected = sample(vec2<i32>(advectPos));
      
      density = advected.r * 0.995;
      temp = advected.g * 0.98;
      
      // Continuous smoke source at bottom (high Y in texture)
      if (uv.y > 0.88) {
        let pattern = sin(uv.x * 15.0 + u.time * 2.0) * 0.5 + 0.5;
        let pattern2 = sin(uv.x * 7.0 - u.time) * 0.5 + 0.5;
        if (pattern * pattern2 > 0.25) {
          let edge = (uv.y - 0.88) / 0.12;
          density += 1.5 * edge;
          temp += 2.0 * edge;
          vy -= 1.5;  // upward velocity in texture space
        }
      }
      
      textureStore(dst, C, vec4<f32>(
        clamp(density, 0.0, 10.0),
        clamp(temp, 0.0, 10.0),
        clamp(vx, -50.0, 50.0),
        clamp(vy, -50.0, 50.0)
      ));
    }
  `,
  
  // Render shader (volumetric smoke appearance)
  /* wgsl */`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let density = data.r;
      let temp = data.g;
      
      var col = vec3<f32>(0.0);
      
      // Hot embers (from temperature)
      col += vec3<f32>(1.0, 0.9, 0.7) * pow(temp, 3.0) * 4.0;
      col += vec3<f32>(1.0, 0.5, 0.2) * pow(temp, 2.0) * 2.0;
      col += vec3<f32>(0.9, 0.2, 0.1) * pow(temp, 1.0) * 1.0;
      
      // Smoke color (volumetric gray)
      let smokeBase = vec3<f32>(0.15, 0.15, 0.18);
      let smokeDark = vec3<f32>(0.02, 0.02, 0.03);
      let smokeCol = mix(smokeBase, smokeDark, density * 0.1);
      
      // Blend smoke over embers
      let smokeOpacity = 1.0 - exp(-density * 0.4);
      col = mix(col, smokeCol, smokeOpacity * 0.7);
      
      // Add volumetric scattering (light from above)
      let scatter = density * 0.08;
      col += vec3<f32>(0.3, 0.35, 0.45) * scatter;
      
      // Self-shadowing approximation
      col *= 1.0 - density * 0.05;
      
      // Tone mapping
      col = col / (col + 1.0);
      col = pow(col, vec3<f32>(0.85));
      
      return vec4<f32>(col, 1.0);
    }
  `
);
</script>
</body>
</html>