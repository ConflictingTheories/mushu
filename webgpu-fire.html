<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>gpu() â€” WebGPU Fire Simulation</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// gpu() â€” WebGPU Fire Simulation
// Hold & drag mouse to ignite flames!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const gpu = async (computeCode, renderCode) => {
  if (!navigator.gpu) {
    document.body.innerHTML = `
      <div style="color:#fff;font-family:system-ui;padding:40px;text-align:center">
        <h1>WebGPU Not Supported</h1>
        <p>Use Chrome 129+ or Edge with WebGPU enabled.</p>
        <p>Try the WebGL version: <a href="fire.html" style="color:#f80">fire.html</a></p>
      </div>`;
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();

  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  canvas.style.cssText = 'position:fixed;inset:0;width:100%;height:100%';

  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();

  let width, height;

  const resize = () => {
    const d = devicePixelRatio * 0.5; // Half res for performance
    width = Math.floor(innerWidth * d);
    height = Math.floor(innerHeight * d);
    canvas.width = width;
    canvas.height = height;
    context.configure({ device, format, alphaMode: 'premultiplied' });
  };
  resize();
  addEventListener('resize', resize);

  const mouse = [0, 0, 0, 0];
  let mouseDown = false;
  addEventListener('mousemove', e => {
    mouse[2] = mouse[0];
    mouse[3] = mouse[1];
    mouse[0] = e.clientX / innerWidth;
    mouse[1] = e.clientY / innerHeight;
  });
  addEventListener('mousedown', () => mouseDown = true);
  addEventListener('mouseup', () => mouseDown = false);

  const createStateTexture = () => device.createTexture({
    size: [width, height],
    format: 'rgba16float',
    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
  });

  let stateA = createStateTexture();
  let stateB = createStateTexture();

  const uniformBuffer = device.createBuffer({
    size: 48,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  const computeModule = device.createShaderModule({
    code: /* wgsl */`
      struct Uniforms {
        time: f32,
        mouseX: f32,
        mouseY: f32,
        mouseDown: f32,
        prevMouseX: f32,
        prevMouseY: f32,
        width: f32,
        height: f32,
      }
      
      @group(0) @binding(0) var<uniform> u: Uniforms;
      @group(0) @binding(1) var src: texture_storage_2d<rgba16float, read>;
      @group(0) @binding(2) var dst: texture_storage_2d<rgba16float, write>;

      fn sample(c: vec2<i32>) -> vec4<f32> {
        let dims = vec2<i32>(textureDimensions(src));
        let p = clamp(c, vec2<i32>(0), dims - vec2<i32>(1));
        return textureLoad(src, p);
      }

      ${computeCode}

      @compute @workgroup_size(16, 16)
      fn main(@builtin(global_invocation_id) id: vec3<u32>) {
        let C = vec2<i32>(id.xy);
        let dims = textureDimensions(src);
        if (u32(C.x) >= dims.x || u32(C.y) >= dims.y) { return; }
        let uv = vec2<f32>(C) / vec2<f32>(dims);
        compute(C, uv);
      }
    `
  });

  const computeBindGroupLayout = device.createBindGroupLayout({
    entries: [
      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
      { binding: 1, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: 'read-only', format: 'rgba16float' } },
      { binding: 2, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: 'write-only', format: 'rgba16float' } }
    ]
  });

  const computePipeline = device.createComputePipeline({
    layout: device.createPipelineLayout({ bindGroupLayouts: [computeBindGroupLayout] }),
    compute: { module: computeModule, entryPoint: 'main' }
  });

  const renderModule = device.createShaderModule({
    code: /* wgsl */`
      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) uv: vec2<f32>,
      }

      @vertex
      fn vs(@builtin(vertex_index) i: u32) -> VertexOutput {
        var pos = array<vec2<f32>, 3>(
          vec2<f32>(-1.0, -1.0),
          vec2<f32>(3.0, -1.0),
          vec2<f32>(-1.0, 3.0)
        );
        var output: VertexOutput;
        output.position = vec4<f32>(pos[i], 0.0, 1.0);
        output.uv = pos[i] * 0.5 + 0.5;
        return output;
      }

      @group(0) @binding(0) var tex: texture_2d<f32>;
      @group(0) @binding(1) var samp: sampler;

      ${renderCode}

      @fragment
      fn fs(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
        let data = textureSample(tex, samp, uv);
        return render(data, uv);
      }
    `
  });

  const renderPipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: { module: renderModule, entryPoint: 'vs' },
    fragment: { module: renderModule, entryPoint: 'fs', targets: [{ format }] },
    primitive: { topology: 'triangle-list' }
  });

  const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });

  const loop = () => {
    const time = performance.now() * 0.001;

    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([
      time, mouse[0], mouse[1], mouseDown ? 1.0 : 0.0,
      mouse[2], mouse[3], width, height
    ]));

    const encoder = device.createCommandEncoder();

    const computePass = encoder.beginComputePass();
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, device.createBindGroup({
      layout: computeBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: uniformBuffer } },
        { binding: 1, resource: stateA.createView() },
        { binding: 2, resource: stateB.createView() }
      ]
    }));
    computePass.dispatchWorkgroups(Math.ceil(width / 16), Math.ceil(height / 16));
    computePass.end();

    const renderPass = encoder.beginRenderPass({
      colorAttachments: [{
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 1],
        loadOp: 'clear',
        storeOp: 'store'
      }]
    });
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, device.createBindGroup({
      layout: renderPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: stateB.createView() },
        { binding: 1, resource: sampler }
      ]
    }));
    renderPass.draw(3);
    renderPass.end();

    device.queue.submit([encoder.finish()]);
    [stateA, stateB] = [stateB, stateA];
    requestAnimationFrame(loop);
  };
  loop();

  console.log('%c ğŸ”¥ WebGPU Fire Ready ', 'background: #ff4500; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold;');
  console.log('Hold & drag mouse to ignite flames!');
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIRE SIMULATION COMPUTE SHADER
// Channels: R=fuel, G=heat, B=smoke, A=velocity
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

gpu(
  // Compute shader (fire simulation)
  /* wgsl */`
    fn hash(p: vec2<f32>) -> f32 {
      return fract(sin(dot(p, vec2<f32>(12.9898, 78.233))) * 43758.5453);
    }

    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      var fuel = data.r;
      var heat = data.g;
      var smoke = data.b;
      
      // Sample neighbors - note: in texture space +Y is down on screen
      let up = sample(C + vec2<i32>(0, -1));    // visual up = texture -Y
      let down = sample(C + vec2<i32>(0, 1));   // visual down = texture +Y
      let left = sample(C - vec2<i32>(1, 0));
      let right = sample(C + vec2<i32>(1, 0));
      
      // Heat diffusion
      let diffusion = 0.1;
      heat += diffusion * (up.g + down.g + left.g + right.g - 4.0 * heat);
      
      // Buoyancy (heat rises - get heat from below in visual space)
      heat = mix(heat, down.g, 0.2);
      
      // Wind (slight right drift)
      heat = mix(heat, left.g, 0.02);
      
      // Fuel diffusion
      fuel += 0.04 * (up.r + down.r + left.r + right.r - 4.0 * fuel);
      fuel = mix(fuel, down.r, 0.1);
      
      // Decay
      fuel *= 0.97;
      heat *= 0.985;
      smoke *= 0.99;
      
      // Mouse ignition (flip mouse Y for texture space)
      let mouse = vec2<f32>(u.mouseX, 1.0 - u.mouseY);
      let d = length(uv - mouse);
      if (u.mouseDown > 0.5 && d < 0.1) {
        let intensity = (1.0 - d / 0.1) * 10.0;
        fuel += intensity;
        heat += intensity * 2.5;
      }
      
      // Bottom fire source (high Y in texture = bottom on screen)
      if (uv.y > 0.9) {
        let pattern = sin(uv.x * 25.0 + u.time * 4.0) * 0.5 + 0.5;
        let pattern2 = sin(uv.x * 8.0 - u.time * 2.0) * 0.5 + 0.5;
        if (pattern * pattern2 > 0.3) {
          let intensity = 1.5 * (uv.y - 0.9) / 0.1;
          fuel += intensity;
          heat += intensity * 2.5;
        }
      }
      
      // Combustion
      let burn = min(heat * 0.5, fuel);
      heat += burn * 0.4;
      fuel -= burn;
      smoke += burn * 0.6;
      
      // Smoke rises (get from below = texture +Y)
      smoke = mix(smoke, down.b, 0.12);
      
      textureStore(dst, C, vec4<f32>(
        clamp(fuel, 0.0, 20.0),
        clamp(heat, 0.0, 20.0),
        clamp(smoke, 0.0, 10.0),
        1.0
      ));
    }
  `,
  
  // Render shader (fire colors)
  /* wgsl */`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let fuel = data.r;
      let heat = data.g;
      let smoke = data.b;
      
      var col = vec3<f32>(0.0);
      
      // White-yellow core (very hot)
      col += vec3<f32>(1.0, 0.95, 0.85) * pow(heat, 3.5) * 5.0;
      
      // Yellow flames
      col += vec3<f32>(1.0, 0.8, 0.2) * pow(heat, 2.0) * 3.0;
      
      // Orange flames
      col += vec3<f32>(1.0, 0.4, 0.05) * pow(heat, 1.3) * 2.0;
      
      // Red base
      col += vec3<f32>(0.9, 0.15, 0.0) * pow(heat, 0.8) * 1.0;
      
      // Smoke overlay
      let smokeColor = vec3<f32>(0.02, 0.02, 0.03);
      col = mix(col, smokeColor, clamp(smoke * 0.3, 0.0, 0.85));
      
      // Embers
      let embers = fuel * (1.0 - heat * 0.15);
      col += vec3<f32>(1.0, 0.4, 0.1) * embers * 0.4;
      
      // Tone mapping
      col = 1.0 - exp(-col * 0.7);
      col = pow(col, vec3<f32>(0.88));
      
      return vec4<f32>(col, 1.0);
    }
  `
);
</script>
</body>
</html>