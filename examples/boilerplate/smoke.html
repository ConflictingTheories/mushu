<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Vanilla WebGL2 Smoke - Boilerplate</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 16px;
      border-radius: 6px;
      z-index: 100;
      pointer-events: none;
    }

    .info code {
      color: #3b82f6;
    }
  </style>
<link rel="stylesheet" href="../common.css">
<script type="module" src="/examples/code-viewer.js"></script>
</head>

<body>
  <div class="info">ğŸ“ <code>Boilerplate</code> - Vanilla WebGL2 Smoke | Move mouse to interact</div>
  <canvas id="canvas"></canvas>
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VANILLA WEBGL2 SMOKE - BOILERPLATE EXAMPLE
    // procedural one-shader effect (matches glsl/smoke.html logic)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      document.body.innerHTML = '<h1 style="color:#fff;text-align:center;padding:40px">WebGL2 not supported</h1>';
      throw new Error('WebGL2 not supported');
    }

    const vertexShaderSource = `#version 300 es
void main() {
  vec2 pos[3] = vec2[](vec2(-1,-1), vec2(3,-1), vec2(-1,3));
  gl_Position = vec4(pos[gl_VertexID], 0, 1);
}`;

    const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 fragColor;

uniform vec2 uResolution;
uniform float uTime;
uniform vec2 uMouse;

float hash(vec2 p) {
  vec3 p3 = fract(vec3(p.xyx) * 0.1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
  return mix(
    mix(hash(i), hash(i + vec2(1,0)), f.x),
    mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x),
    f.y
  );
}

float fbm(vec2 p, int octaves) {
  float f = 0.0;
  float amp = 0.5;
  mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);
  for (int i = 0; i < 8; i++) {
    if (i >= octaves) break;
    f += amp * noise(p);
    p = rot * p * 2.0;
    amp *= 0.5;
  }
  return f;
}

void main() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec2 p = (gl_FragCoord.xy - uResolution * 0.5) / uResolution.y;
  float t = uTime * 0.4;
  
  // Base smoke columns
  float smoke = 0.0;
  
  // Multiple smoke streams
  for (int i = 0; i < 5; i++) {
    float fi = float(i);
    float xOffset = sin(fi * 1.3) * 0.3;
    vec2 smokePos = vec2(p.x - xOffset, p.y + 0.4);
    
    // Rising motion with turbulence
    float rise = fbm(vec2(smokePos.x * 2.0, t + fi), 4);
    smokePos.y += rise * 0.3;
    smokePos.x += sin(smokePos.y * 3.0 + t + fi) * 0.08;
    
    // Turbulent distortion
    float turb = fbm(smokePos * 4.0 + t * 0.5 + fi, 5);
    smokePos += (turb - 0.5) * 0.15;
    
    // Smoke density falloff
    float dist = length(smokePos * vec2(3.0, 1.0));
    float column = exp(-dist * 2.5);
    
    // Add wispy tendrils
    float tendrils = fbm(smokePos * 8.0 - vec2(0, t), 3);
    column *= (0.5 + tendrils * 0.8);
    
    smoke += column * (0.3 + 0.2 * sin(fi));
  }
  
  // Add swirling vortices
  float swirl = fbm(p * 3.0 + t * 0.3, 4);
  smoke += swirl * 0.2 * (1.0 - uv.y);
  
  // Mouse interaction - disperse smoke
  vec2 mouseP = (uMouse - 0.5) * vec2(uResolution.x / uResolution.y, 1.0);
  // Match mushu mouse coord system
  vec2 m = (uMouse - 0.5); 
  m.x *= uResolution.x / uResolution.y;

  float mouseDist = length(p - m);
  float mouseInfluence = exp(-mouseDist * 6.0);
  smoke += mouseInfluence * 0.5;
  smoke *= 1.0 - mouseInfluence * 0.4; // Dispersal effect
  
  // Volumetric lighting
  vec3 smokeColorLight = vec3(0.65, 0.68, 0.72);
  vec3 smokeColorDark = vec3(0.15, 0.15, 0.18);
  
  // Light from above
  float topLight = uv.y * 0.3;
  vec3 smokeColor = mix(smokeColorDark, smokeColorLight, topLight + smoke * 0.3);
  
  // Rim lighting
  float rim = pow(smoke, 0.5) * 0.3;
  smokeColor += vec3(0.2, 0.22, 0.25) * rim;
  
  // Beer-Lambert absorption
  float density = clamp(smoke, 0.0, 1.0);
  float transmittance = exp(-density * 2.0);
  
  // Background gradient
  vec3 bgColor = mix(vec3(0.02, 0.02, 0.04), vec3(0.08, 0.08, 0.12), uv.y);
  
  // Composite smoke over background
  vec3 color = mix(smokeColor, bgColor, transmittance);
  
  // Add subtle glow at source
  float sourceGlow = exp(-length(p + vec2(0, 0.5)) * 3.0) * 0.5;
  color += vec3(1.0, 0.6, 0.3) * sourceGlow * (1.0 - transmittance);
  
  // Film grain
  float grain = (hash(gl_FragCoord.xy + uTime) - 0.5) * 0.03;
  color += grain;
  
  // Vignette
  float vignette = 1.0 - length(uv - 0.5) * 0.4;
  color *= vignette;
  
  fragColor = vec4(color, 1.0);
}`;

    // Shader helpers
    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(vertSource, fragSource) {
      const vs = createShader(gl.VERTEX_SHADER, vertSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(vertexShaderSource, fragmentShaderSource);

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    let mouse = [0.5, 0.5];

    canvas.addEventListener('mousemove', e => {
      mouse[0] = e.clientX / window.innerWidth;
      mouse[1] = 1.0 - e.clientY / window.innerHeight;
    });
    canvas.addEventListener('touchmove', e => {
      if (e.touches.length > 0) {
        mouse[0] = e.touches[0].clientX / window.innerWidth;
        mouse[1] = 1.0 - e.touches[0].clientY / window.innerHeight;
      }
    }, { passive: true });

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    function render(time) {
      time *= 0.001;

      gl.useProgram(program);
      gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'uTime'), time);
      gl.uniform2f(gl.getUniformLocation(program, 'uMouse'), mouse[0], mouse[1]);

      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // FPS Counter
    (function () {
      const fpsDiv = document.createElement('div');
      fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
      document.body.appendChild(fpsDiv);
      let frames = 0, lastTime = performance.now();
      function updateFPS() {
        frames++;
        const now = performance.now();
        if (now - lastTime >= 500) {
          fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
          frames = 0; lastTime = now;
        }
        requestAnimationFrame(updateFPS);
      }
      updateFPS();
    })();

    console.log('%c ğŸ’¨ Vanilla WebGL2 Smoke ', 'background: #3b82f6; color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
  </script>
</body>

</html>