<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu — Underwater Caustics Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { yo, shader, fps } from '../src/index.js';

// ═══════════════════════════════════════════════════════════════════════════
// Underwater Caustics
// Simulates light patterns on the ocean floor from surface waves
// Move mouse to look around!
// ═══════════════════════════════════════════════════════════════════════════

yo(document.getElementById('c'))
  .use(shader(`
    //─────────────────────────────────────────────────────────────────────
    // Noise functions for wave generation
    //─────────────────────────────────────────────────────────────────────
    
    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }
    
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);
      
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      
      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }
    
    float fbm(vec2 p) {
      float f = 0.0;
      float amp = 0.5;
      for (int i = 0; i < 5; i++) {
        f += amp * noise(p);
        p *= 2.03;
        amp *= 0.48;
      }
      return f;
    }
    
    //─────────────────────────────────────────────────────────────────────
    // Water surface simulation
    //─────────────────────────────────────────────────────────────────────
    
    float waterHeight(vec2 p, float t) {
      float h = 0.0;
      
      // Large swells
      h += sin(p.x * 0.5 + t * 0.3) * sin(p.y * 0.4 - t * 0.2) * 0.4;
      
      // Medium waves
      h += sin(p.x * 1.2 - t * 0.8) * sin(p.y * 1.5 + t * 0.6) * 0.2;
      h += sin((p.x + p.y) * 0.8 + t * 0.5) * 0.15;
      
      // Small ripples via noise
      h += fbm(p * 3.0 + t * 0.5) * 0.15;
      h += noise(p * 8.0 - t * 2.0) * 0.05;
      
      return h;
    }
    
    vec3 waterNormal(vec2 p, float t) {
      float eps = 0.01;
      float h = waterHeight(p, t);
      float hx = waterHeight(p + vec2(eps, 0.0), t);
      float hy = waterHeight(p + vec2(0.0, eps), t);
      
      return normalize(vec3(h - hx, eps * 5.0, h - hy));
    }
    
    //─────────────────────────────────────────────────────────────────────
    // Caustic pattern generation
    //─────────────────────────────────────────────────────────────────────
    
    float causticPattern(vec2 p, float t) {
      float caustic = 0.0;
      
      // Layer multiple caustic frequencies
      for (int i = 1; i < 6; i++) {
        float fi = float(i);
        float scale = fi * 2.0;
        float speed = 0.15 * fi;
        
        vec2 q = p * scale;
        q += vec2(sin(t * speed), cos(t * speed * 0.7)) * 0.5;
        
        // Create caustic-like pattern from wave interference
        float wave1 = sin(q.x + sin(q.y * 1.3 + t * speed));
        float wave2 = sin(q.y + cos(q.x * 1.2 - t * speed * 0.8));
        float wave3 = sin((q.x + q.y) * 0.7 + t * speed * 0.5);
        
        float c = wave1 * wave2 + wave2 * wave3 + wave3 * wave1;
        c = abs(c);
        c = pow(c, 2.5);
        
        caustic += c / fi;
      }
      
      return caustic * 0.3;
    }
    
    // Voronoi-based caustic highlights
    float voronoiCaustic(vec2 p, float t) {
      vec2 n = floor(p);
      vec2 f = fract(p);
      
      float minDist = 1.0;
      
      for (int j = -1; j <= 1; j++) {
        for (int i = -1; i <= 1; i++) {
          vec2 b = vec2(float(i), float(j));
          vec2 r = b - f + hash(n + b) * 0.8;
          r += 0.3 * sin(t * 0.5 + hash(n + b) * 6.28);
          
          float d = dot(r, r);
          minDist = min(minDist, d);
        }
      }
      
      return pow(1.0 - sqrt(minDist), 4.0);
    }
    
    //─────────────────────────────────────────────────────────────────────
    // Main render
    //─────────────────────────────────────────────────────────────────────
    
    void mainImage(out vec4 O, vec2 C) {
      vec2 uv = (C - resolution * 0.5) / resolution.y;
      float t = time * 0.5;
      
      // Camera movement based on mouse
      vec2 offset = (mouse - 0.5) * 0.5;
      uv += offset;
      
      // Ocean floor position
      vec2 floorPos = uv * 4.0;
      
      // Calculate water surface normal for light refraction
      vec3 normal = waterNormal(floorPos * 0.5, t);
      
      // Light ray refraction through water surface
      vec3 lightDir = normalize(vec3(0.2, 1.0, 0.3));
      vec3 refracted = refract(-lightDir, normal, 1.0 / 1.33);
      
      // Offset floor position by refracted light
      vec2 causticPos = floorPos + refracted.xz * 2.0;
      
      // Generate caustic patterns
      float caustic1 = causticPattern(causticPos, t);
      float caustic2 = voronoiCaustic(causticPos * 1.5, t);
      float caustic3 = causticPattern(causticPos * 0.5 + 10.0, t * 0.7);
      
      float totalCaustic = caustic1 * 0.5 + caustic2 * 0.8 + caustic3 * 0.3;
      
      // Ocean floor base colors
      vec3 sandColor = vec3(0.6, 0.5, 0.35);
      vec3 rockColor = vec3(0.3, 0.28, 0.25);
      
      // Floor texture
      float floorNoise = fbm(floorPos * 2.0);
      vec3 floorColor = mix(sandColor, rockColor, floorNoise * 0.5);
      
      // Add some darker patches
      float patches = noise(floorPos * 0.5);
      floorColor *= 0.8 + patches * 0.4;
      
      // Water depth color (absorbs red light first)
      vec3 waterTint = vec3(0.1, 0.4, 0.6);
      float depth = 0.6;
      floorColor = mix(floorColor, waterTint, depth * 0.4);
      
      // Apply caustics - light focusing effect
      vec3 causticLight = vec3(0.9, 0.95, 1.0);
      floorColor += causticLight * totalCaustic * 1.5;
      
      // Ambient ocean glow
      floorColor += vec3(0.05, 0.15, 0.2);
      
      // Light rays from surface
      float rays = pow(max(0.0, dot(normal, lightDir)), 8.0);
      floorColor += vec3(0.3, 0.5, 0.6) * rays * 0.3;
      
      // Depth fog
      float fogDist = length(uv) * 0.5;
      vec3 fogColor = vec3(0.1, 0.25, 0.4);
      floorColor = mix(floorColor, fogColor, smoothstep(0.0, 2.0, fogDist) * 0.5);
      
      // Vignette
      float vignette = 1.0 - length(uv) * 0.4;
      floorColor *= vignette;
      
      // Tone mapping
      floorColor = floorColor / (floorColor + 0.8);
      floorColor = pow(floorColor, vec3(0.9));
      
      // Subtle blue push
      floorColor.b += 0.02;
      
      O = vec4(floorColor, 1.0);
    }
  `))
  .use(fps())
  .go();

console.log('%c ✨ mushu Caustics Ready ', 'background: linear-gradient(90deg, #004466, #006699); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Move mouse to look around the ocean floor!');
</script>
</body>
</html>
