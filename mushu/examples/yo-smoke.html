<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” YO Smoke Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { yo, simulation, fps } from '../src/core/yo.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YO Volumetric Smoke Simulation (WebGL2)
// 
// Features:
//   â€¢ Navier-Stokes inspired fluid dynamics
//   â€¢ Vorticity confinement for swirling details
//   â€¢ Beer-Lambert light scattering
//   â€¢ Temperature-based buoyancy
//   â€¢ Multi-scale turbulence injection
// 
// Click and drag to add smoke!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const sim = simulation({ scale: 0.5, iterations: 3 });

sim.simulate(`
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Noise Functions for Turbulence
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  float hash(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
  }
  
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(
      mix(hash(i), hash(i + vec2(1,0)), u.x),
      mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x),
      u.y
    );
  }
  
  float fbm(vec2 p, int octaves) {
    float v = 0.0, a = 0.5;
    mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);
    for (int i = 0; i < 6; i++) {
      if (i >= octaves) break;
      v += a * noise(p);
      p = rot * p * 2.0;
      a *= 0.5;
    }
    return v;
  }
  
  // Curl noise for divergence-free velocity
  vec2 curlNoise(vec2 p) {
    float eps = 0.01;
    float n = fbm(p, 4);
    float nx = fbm(p + vec2(eps, 0.0), 4);
    float ny = fbm(p + vec2(0.0, eps), 4);
    return vec2(ny - n, -(nx - n)) / eps;
  }

  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec2 texel = 1.0 / resolution;
    vec4 data = sample(vec2(0));
    
    // Sample neighbors for fluid simulation
    vec4 up = sample(vec2(0, 1));
    vec4 down = sample(vec2(0, -1));
    vec4 left = sample(vec2(-1, 0));
    vec4 right = sample(vec2(1, 0));
    vec4 upLeft = sample(vec2(-1, 1));
    vec4 upRight = sample(vec2(1, 1));
    vec4 downLeft = sample(vec2(-1, -1));
    vec4 downRight = sample(vec2(1, -1));
    
    // Unpack state: R = density, G = temperature, BA = velocity
    float density = data.r;
    float temp = data.g;
    vec2 vel = (data.ba - 0.5) * 2.0;
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Vorticity Confinement - adds swirling detail
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    // Compute vorticity (curl of velocity field)
    vec2 velUp = (up.ba - 0.5) * 2.0;
    vec2 velDown = (down.ba - 0.5) * 2.0;
    vec2 velLeft = (left.ba - 0.5) * 2.0;
    vec2 velRight = (right.ba - 0.5) * 2.0;
    
    float vorticity = (velRight.y - velLeft.y) - (velUp.x - velDown.x);
    
    // Gradient of vorticity magnitude
    float vortUp = abs((upRight.a - upLeft.a) - (up.a - up.a));
    float vortDown = abs((downRight.a - downLeft.a) - (down.a - down.a));
    float vortLeft = abs((upLeft.a - downLeft.a) - (left.a - left.a));
    float vortRight = abs((upRight.a - downRight.a) - (right.a - right.a));
    
    vec2 vortGrad = vec2(vortRight - vortLeft, vortUp - vortDown);
    float vortLen = length(vortGrad);
    if (vortLen > 0.0001) {
      vortGrad /= vortLen;
      // Apply vorticity confinement force
      vel += vortGrad * vorticity * 0.15;
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Temperature-based Buoyancy
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    float buoyancy = temp * 0.08 - density * 0.02;
    vel.y += buoyancy;
    
    // Temperature diffusion and cooling
    float avgTemp = (up.g + down.g + left.g + right.g) * 0.25;
    temp = mix(temp, avgTemp, 0.15);
    temp *= 0.992; // Cooling rate
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Multi-scale Turbulence Injection
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    vec2 turbPos = uv * 6.0 + vec2(time * 0.3, time * 0.2);
    vec2 curlVel = curlNoise(turbPos) * 0.025;
    vel += curlVel * (0.3 + density * 0.5);
    
    // Small-scale noise for detail
    float microTurb = noise(uv * 30.0 + time * 2.0) - 0.5;
    vel.x += microTurb * 0.01 * density;
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Advection (semi-Lagrangian)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    vec2 advectUV = uv - vel * 0.012;
    advectUV = clamp(advectUV, texel, 1.0 - texel);
    vec4 advected = texture(backbuffer, advectUV);
    
    density = mix(density, advected.r, 0.85);
    temp = mix(temp, advected.g, 0.85);
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Density Diffusion
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    float avgDensity = (up.r + down.r + left.r + right.r) * 0.25;
    density = mix(density, avgDensity, 0.08);
    
    // Dissipation - smoke fades over time
    density *= 0.997;
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Mouse Smoke Emission
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    float d = length(uv - mouse);
    if (mouseDown > 0.5 && d < 0.1) {
      float falloff = pow(1.0 - d / 0.1, 2.0);
      density += falloff * 0.6;
      temp += falloff * 0.8;
      
      // Add velocity based on mouse movement
      vec2 mouseVel = (mouse - mousePrev) * 10.0;
      vel += mouseVel * falloff * 0.3;
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Auto-emitters at Bottom
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    if (uv.y < 0.08) {
      float edge = 1.0 - uv.y / 0.08;
      edge = edge * edge;
      
      // Multiple emitter sources with varying behavior
      float emitter1 = fbm(vec2(uv.x * 10.0, time * 1.5), 3);
      float emitter2 = noise(vec2(uv.x * 25.0, time * 3.0));
      float emitter3 = sin(uv.x * 15.0 + time * 2.0) * 0.5 + 0.5;
      
      float combined = emitter1 * emitter2 * emitter3;
      
      if (combined > 0.25) {
        float intensity = (combined - 0.25) * 4.0 * edge;
        density += intensity * 0.08;
        temp += intensity * 0.15;
      }
    }
    
    // Velocity damping
    vel *= 0.98;
    
    // Clamp and pack output
    density = clamp(density, 0.0, 2.0);
    temp = clamp(temp, 0.0, 1.0);
    vel = clamp(vel, vec2(-2.0), vec2(2.0));
    
    O = vec4(density, temp, vel * 0.5 + 0.5);
  }
`);

sim.display(`
  void mainImage(out vec4 O, vec2 C) {
    vec2 uv = C / resolution;
    vec2 px = 1.0 / resolution;
    
    // Multi-sample for smoother appearance
    vec4 data = texture(backbuffer, uv);
    vec4 dataL = texture(backbuffer, uv - vec2(px.x, 0.0));
    vec4 dataR = texture(backbuffer, uv + vec2(px.x, 0.0));
    vec4 dataU = texture(backbuffer, uv + vec2(0.0, px.y));
    vec4 dataD = texture(backbuffer, uv - vec2(0.0, px.y));
    
    float density = data.r;
    float temp = data.g;
    
    // Smooth density for rendering
    float smoothDensity = (density + dataL.r + dataR.r + dataU.r + dataD.r) / 5.0;
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Beer-Lambert Law for Light Scattering
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    float absorption = 1.5;
    float transmittance = exp(-smoothDensity * absorption);
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Smoke Color with Temperature Influence
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    // Cool smoke is gray-blue, warm smoke has slight yellow tint
    vec3 coolSmoke = vec3(0.75, 0.78, 0.85);
    vec3 warmSmoke = vec3(0.9, 0.88, 0.82);
    vec3 smokeColor = mix(coolSmoke, warmSmoke, temp);
    
    // Darker smoke at higher densities
    vec3 denseSmoke = vec3(0.25, 0.26, 0.28);
    smokeColor = mix(smokeColor, denseSmoke, smoothDensity * 0.4);
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Lighting
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    // Compute gradient for pseudo-lighting
    float gradX = dataR.r - dataL.r;
    float gradY = dataU.r - dataD.r;
    vec3 normal = normalize(vec3(-gradX * 5.0, -gradY * 5.0, 1.0));
    
    vec3 lightDir = normalize(vec3(0.3, 0.8, 0.5));
    float diffuse = max(dot(normal, lightDir), 0.0);
    
    // Rim lighting from below
    vec3 rimDir = normalize(vec3(0.0, -1.0, 0.3));
    float rim = pow(max(dot(normal, rimDir), 0.0), 2.0);
    
    smokeColor *= 0.6 + diffuse * 0.4;
    smokeColor += vec3(0.9, 0.85, 0.7) * rim * temp * 0.3;
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Background Gradient
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    vec3 bgTop = vec3(0.02, 0.025, 0.04);
    vec3 bgBottom = vec3(0.04, 0.04, 0.05);
    vec3 bg = mix(bgBottom, bgTop, uv.y);
    
    // Subtle radial gradient
    float vignette = 1.0 - length(uv - 0.5) * 0.3;
    bg *= vignette;
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Final Compositing
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    vec3 color = mix(smokeColor, bg, transmittance);
    
    // Subtle blue atmospheric scattering
    color = mix(color, vec3(0.3, 0.4, 0.5), (1.0 - transmittance) * 0.08);
    
    // Tone mapping
    color = color / (color + 0.5);
    color = pow(color, vec3(0.95));
    
    O = vec4(color, 1.0);
  }
`);

yo(document.getElementById('c'))
  .scale(1)
  .use(sim)
  .use(fps())
  .go();

console.log('%c ğŸ’¨ mushu YO Smoke Ready ', 'background: linear-gradient(90deg, #556, #889); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Click and drag to add smoke!');
</script>
</body>
</html>
