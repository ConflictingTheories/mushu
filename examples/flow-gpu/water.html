<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” GPU Flow Water Demo</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; }
    .info { position: fixed; top: 10px; left: 10px; color: #fff; font: 14px monospace; 
            background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 6px; z-index: 100; }
    .info code { color: #00bbdd; }
    .home-link { position: fixed; bottom: 1rem; right: 1rem; background: linear-gradient(135deg, #ff6b6b, #feca57); 
                 color: #000; padding: 0.75rem 1.5rem; border-radius: 25px; text-decoration: none; 
                 font-weight: bold; font-size: 0.85rem; box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3); 
                 transition: all 0.2s; z-index: 100; font-family: monospace; }
    .home-link:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4); }
  </style>
</head>
<body>
<div class="info">ğŸŒŠ <code>mushu().gpu().flow()</code> Water | WebGPU Fluent API</div>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { mushu } from '../../src/index.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YOGPU Water Simulation (WebGPU Fluent API)
// 
// Uses the yoGPU() fluent builder for WebGPU compute+render pipeline
// Features:
//   â€¢ 8-neighbor wave equation
//   â€¢ Dynamic foam generation
//   â€¢ Fresnel reflections
//   â€¢ Animated caustics
//   â€¢ Interactive ripples
// 
// Click and drag to create ripples!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

mushu('#c').gpu().flow()
  .scale(0.5)
  .simulate(`
    fn hash(p: vec2<f32>) -> f32 {
      return fract(sin(dot(p, vec2<f32>(127.1, 311.7))) * 43758.5453);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
      );
    }

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
      let dims = vec2<i32>(textureDimensions(src));
      let C = vec2<i32>(id.xy);
      if (C.x >= dims.x || C.y >= dims.y) { return; }
      
      let uv = vec2<f32>(C) / vec2<f32>(dims);
      var data = sample(C);
      
      // Extended neighborhood using helper
      let up = sampleOffset(C, vec2<i32>(0, 1));
      let down = sampleOffset(C, vec2<i32>(0, -1));
      let left = sampleOffset(C, vec2<i32>(-1, 0));
      let right = sampleOffset(C, vec2<i32>(1, 0));
      let upLeft = sampleOffset(C, vec2<i32>(-1, 1));
      let upRight = sampleOffset(C, vec2<i32>(1, 1));
      let downLeft = sampleOffset(C, vec2<i32>(-1, -1));
      let downRight = sampleOffset(C, vec2<i32>(1, -1));
      
      // State: R = height, G = velocity, B = foam
      var height = data.r;
      var velocity = data.g;
      var foam = data.b;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Wave Equation (8-neighbor Laplacian)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let laplacian = (
        up.r + down.r + left.r + right.r +
        (upLeft.r + upRight.r + downLeft.r + downRight.r) * 0.5
      ) / 6.0 - height;
      
      velocity += laplacian * 0.46;
      velocity *= 0.996 - abs(height) * 0.006;
      height += velocity;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Foam
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      if (abs(laplacian) > 0.018 && abs(height) > 0.04) {
        foam += abs(laplacian) * 0.1;
      }
      
      let neighborFoam = (up.b + down.b + left.b + right.b) * 0.25;
      foam = mix(foam, neighborFoam, 0.08);
      foam *= 0.985;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Mouse Interaction
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let mousePos = vec2<f32>(u.mouseX, u.mouseY);
      let d = length(uv - mousePos);
      
      if (u.mouseDown > 0.5 && d < 0.055) {
        let falloff = pow(1.0 - d / 0.055, 2.0);
        height += falloff * 0.45;
        foam += falloff * 0.2;
      }
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Random Raindrops
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let dropChance = hash(vec2<f32>(f32(C.x) + u.time * 100.0, f32(C.y) + u.time * 73.0));
      if (dropChance > 0.9998) {
        height += 0.22 + hash(uv + u.time) * 0.15;
        foam += 0.1;
      }
      
      // Wind ripples
      let wind = noise(uv * 12.0 + vec2<f32>(u.time * 0.35, u.time * 0.2)) - 0.5;
      height += wind * 0.002;
      
      // Edge reflection
      if (uv.x < 0.02 || uv.x > 0.98 || uv.y < 0.02 || uv.y > 0.98) {
        velocity *= -0.5;
        height *= 0.9;
      }
      
      textureStore(dst, C, vec4<f32>(
        clamp(height, -1.5, 1.5),
        clamp(velocity, -0.8, 0.8),
        clamp(foam, 0.0, 1.0),
        1.0
      ));
    }
  `)
  .display(`
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      let a = fract(sin(dot(i, vec2<f32>(127.1, 311.7))) * 43758.5453);
      let b = fract(sin(dot(i + vec2<f32>(1.0, 0.0), vec2<f32>(127.1, 311.7))) * 43758.5453);
      let c = fract(sin(dot(i + vec2<f32>(0.0, 1.0), vec2<f32>(127.1, 311.7))) * 43758.5453);
      let d = fract(sin(dot(i + vec2<f32>(1.0, 1.0), vec2<f32>(127.1, 311.7))) * 43758.5453);
      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
    }

    @fragment fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
      let data = textureSample(simTex, texSampler, uv);
      let height = data.r;
      let velocity = data.g;
      let foam = data.b;
      
      // Normal from velocity
      let normal = normalize(vec3<f32>(-velocity * 12.0, -velocity * 12.0, 1.0));
      
      // Fresnel
      let viewDir = vec3<f32>(0.0, 0.0, 1.0);
      let fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 4.0);
      let F = 0.04 + 0.96 * fresnel;
      
      // Lighting
      let lightDir = normalize(vec3<f32>(0.4, 0.6, 0.7));
      let halfDir = normalize(lightDir + viewDir);
      let spec = pow(max(dot(normal, halfDir), 0.0), 128.0);
      
      // Colors
      let deep = vec3<f32>(0.01, 0.04, 0.12);
      let shallow = vec3<f32>(0.05, 0.25, 0.42);
      let sky = vec3<f32>(0.6, 0.8, 0.95);
      let sun = vec3<f32>(1.0, 0.95, 0.85);
      
      var col = mix(deep, shallow, clamp(0.5 + height * 0.4, 0.0, 1.0));
      col = mix(col, mix(sky, sun, spec * 0.5), F * 0.65);
      col += sun * spec * 1.4;
      
      // Caustics
      let causticUV = uv * 25.0;
      let caustic = sin(causticUV.x + height * 8.0 + u.time * 1.5) * 
                    sin(causticUV.y + height * 6.0 + u.time * 1.2);
      col += vec3<f32>(0.12, 0.22, 0.28) * pow(caustic * 0.5 + 0.5, 2.0) * 0.18;
      
      // Foam
      let foamPattern = noise(uv * 70.0 + u.time * 1.5);
      col = mix(col, vec3<f32>(0.95, 0.97, 1.0), smoothstep(0.1, 0.5, foam) * foamPattern * 0.75);
      
      // Tone mapping
      col = col / (col + 0.75);
      col = pow(col, vec3<f32>(0.9));
      
      return vec4<f32>(col, 1.0);
    }
  `)
  .go();

// FPS Counter
(function() {
  const fpsDiv = document.createElement('div');
  fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
  document.body.appendChild(fpsDiv);
  let frames = 0, lastTime = performance.now();
  function updateFPS() {
    frames++;
    const now = performance.now();
    if (now - lastTime >= 500) {
      fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
      frames = 0; lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();

console.log('%c ğŸŒŠ mushu YOGPU Water Ready ', 'background: linear-gradient(90deg, #0066aa, #00bbdd); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Click and drag to create ripples!');
</script>
<a href="index.html" class="home-link">â† Back to Index</a>
</body>
</html>
