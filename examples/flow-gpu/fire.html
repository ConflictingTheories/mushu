<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>mushu â€” GPU Flow Fire Demo</title>
  <link rel="stylesheet" href="../common.css">
  <style>.info code { color: #ff6622; }</style>
  <script type="module" src="/examples/code-viewer.js"></script>
</head>

<body>
  <div class="info">ğŸ”¥ <code>mushu().gpu().flow()</code> Candle Flame | Move mouse to position flame</div>
  <canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
  <script type="module">
    import { mushu } from '/src/index.js';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GPU Flow Candle Flame - Interactive flame that follows mouse
    // 
    // Features:
    //   â€¢ Realistic candle/match flame shape
    //   â€¢ Flame follows mouse position
    //   â€¢ Flickering and dancing motion
    //   â€¢ Proper blackbody coloring
    //   â€¢ Blue base like real candle flames
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    mushu('#c').gpu().flow()
      .scale(1.0)
      .simulate(`
    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
      let dims = vec2<i32>(textureDimensions(src));
      let C = vec2<i32>(id.xy);
      if (C.x >= dims.x || C.y >= dims.y) { return; }
      
      // Pass-through simulation for now, just to keep pipeline active
      // In a real simulation, we'd update state here
      textureStore(dst, C, vec4<f32>(0.0, 0.0, 0.0, 1.0));
    }
      `)
      .display(`
    fn hash(p: vec2<f32>) -> f32 {
      var p3 = fract(vec3<f32>(p.xyx) * 0.1031);
      p3 = p3 + dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
      );
    }
    
    fn fbm(p: vec2<f32>, octaves: i32) -> f32 {
      var value = 0.0;
      var amplitude = 0.5;
      var pos = p;
      for (var i = 0; i < 6; i++) {
        if (i >= octaves) { break; }
        value += amplitude * noise(pos);
        pos = pos * 2.0 + vec2<f32>(1.7, 3.2);
        amplitude *= 0.5;
      }
      return value;
    }

    @fragment fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
      let aspect = u.width / u.height;
      let t = u.time;
      
      // Mouse position is the flame base
      var flameBase = vec2<f32>(u.mouseX, u.mouseY);
      flameBase.y = 1.0 - flameBase.y;
      
      // Position relative to flame base
      var p = uv - flameBase;
      p.x *= aspect;
      p.y = -p.y; // Flame goes UP
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Candle Flame Shape
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Gentle sway
      let sway = sin(t * 3.0) * 0.015 + sin(t * 7.3) * 0.008 + sin(t * 11.0) * 0.004;
      p.x -= sway * p.y * 2.0;
      
      // Flame dimensions
      let flameHeight = 0.22;
      let flameWidth = 0.032;
      
      // Normalized height
      let normalizedY = clamp(p.y / flameHeight, 0.0, 1.0);
      
      // Teardrop profile
      let widthProfile = sin(normalizedY * 3.14159) * (1.0 - normalizedY * 0.4);
      let currentWidth = flameWidth * (0.25 + widthProfile * 0.75);
      
      // Distance from center
      let xDist = abs(p.x) / currentWidth;
      
      // In flame zone
      let inFlameY = step(0.0, p.y) * step(p.y, flameHeight);
      
      // Flame intensity
      var flame = (1.0 - xDist) * inFlameY;
      flame = max(0.0, flame);
      flame = pow(flame, 0.6);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Turbulence & Flickering
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Edge turbulence
      let turb = fbm(vec2<f32>(p.x * 15.0, p.y * 15.0 - t * 8.0), 4);
      flame *= 0.7 + turb * 0.5;
      
      // Inner core (less turbulent)
      let innerFlame = pow(max(0.0, 1.0 - xDist * 1.5), 2.0) * inFlameY;
      
      // Wispy tip
      let wispY = (p.y - flameHeight * 0.65) / (flameHeight * 0.35);
      if (wispY > 0.0) {
        let wisp = fbm(vec2<f32>(p.x * 30.0, -t * 12.0), 3);
        flame *= max(0.0, 1.0 - wispY + wisp * 0.5);
      }
      
      // Global flicker
      let flicker = 0.88 + 0.12 * sin(t * 15.0) * sin(t * 23.0);
      flame *= flicker;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Blackbody Colors
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      var color = vec3<f32>(0.0);
      
      // Dark red outer
      color += vec3<f32>(0.4, 0.02, 0.0) * pow(flame, 0.5) * 0.5;
      
      // Orange
      color += vec3<f32>(1.0, 0.35, 0.0) * pow(flame, 0.8) * 1.2;
      
      // Yellow
      color += vec3<f32>(1.0, 0.7, 0.15) * pow(flame, 1.2) * 1.5;
      
      // White-hot core
      let core = pow(innerFlame, 2.0) * (1.0 - normalizedY);
      color += vec3<f32>(0.9, 0.95, 1.0) * core * 2.0;
      
      // Blue base (real candle characteristic)
      let blueBase = max(0.0, 1.0 - normalizedY * 3.0) * innerFlame;
      color = mix(color, vec3<f32>(0.3, 0.5, 1.0), blueBase * 0.4);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Ember/Wick Glow
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let emberDist = length(p * vec2<f32>(1.0, 3.0));
      let ember = exp(-emberDist * 40.0) * 0.8;
      color += vec3<f32>(1.0, 0.4, 0.1) * ember;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Atmospheric Glow
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let glowDist = length(p * vec2<f32>(1.0, 0.5));
      let glow = exp(-glowDist * 8.0) * 0.3;
      color += vec3<f32>(1.0, 0.3, 0.05) * glow;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Background & Final
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let bg = vec3<f32>(0.01, 0.01, 0.02);
      let ambient = exp(-length(uv - vec2<f32>(flameBase.x, 1.0 - flameBase.y)) * 3.0);
      var finalColor = bg + vec3<f32>(0.15, 0.05, 0.02) * ambient;
      
      finalColor += color;
      
      // Tone mapping
      finalColor = finalColor / (finalColor + 0.8);
      finalColor = pow(finalColor, vec3<f32>(0.9));
      
      // Vignette
      let vignette = 1.0 - length(uv - 0.5) * 0.4;
      finalColor *= vignette;
      
      return vec4<f32>(finalColor, 1.0);
    }
      `)
      .go();

    // FPS Counter
    (function () {
      const fpsDiv = document.createElement('div');
      fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
      document.body.appendChild(fpsDiv);
      let frames = 0, lastTime = performance.now();
      function updateFPS() {
        frames++;
        const now = performance.now();
        if (now - lastTime >= 500) {
          fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
          frames = 0; lastTime = now;
        }
        requestAnimationFrame(updateFPS);
      }
      updateFPS();
    })();

    console.log('%c ğŸ”¥ GPU Flow Candle Flame ', 'background: linear-gradient(90deg, #ff4400, #ff8800); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
    console.log('Move mouse to position the flame!');
  </script>
  <script>
    // Hide home-link if in iframe - run immediately and on load
    function hideIfIframe() {
      if (window.self !== window.top) {
        const link = document.querySelector('.home-link');
        if (link) {
          link.style.display = 'none';
        }
      }
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', hideIfIframe);
    } else {
      hideIfIframe();
    }
  </script>
  <a href="/examples/index.html" class="home-link">â† Back to Index</a>
</body>

</html>