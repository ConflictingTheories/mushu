<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” WebGPU Fire Demo</title>
  <link rel="stylesheet" href="../common.css">
  <style>
    .info code { color: #ff6622; }
  </style>
</head>
<body>
<div class="info">ğŸ”¥ <code>mushu().gpu(compute, render)</code> Candle Flame | Move mouse to position flame</div>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { mushu } from '../../src/index.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WebGPU Candle Flame - Interactive flame that follows mouse
// 
// Features:
//   â€¢ Realistic candle/match flame shape
//   â€¢ Flame follows mouse position
//   â€¢ Flickering and dancing motion
//   â€¢ Proper blackbody coloring
//   â€¢ Glowing ember at base
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

mushu('#c').gpu(
  null,
  /* wgsl */`
    fn hash(p: vec2<f32>) -> f32 {
      var p3 = fract(vec3<f32>(p.xyx) * 0.1031);
      p3 = p3 + dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), u.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), u.x),
        u.y
      );
    }
    
    fn fbm(p: vec2<f32>, octaves: i32) -> f32 {
      var value = 0.0;
      var amplitude = 0.5;
      var pos = p;
      for (var i = 0; i < 6; i++) {
        if (i >= octaves) { break; }
        value += amplitude * noise(pos);
        pos = pos * 2.0 + vec2<f32>(1.7, 3.2);
        amplitude *= 0.5;
      }
      return value;
    }

    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let aspect = u.resolution.x / u.resolution.y;
      let t = u.time;
      
      // Mouse position is the flame base
      var flameBase = u.mouse;
      flameBase.y = 1.0 - flameBase.y; // Flip Y
      
      // Position relative to flame base
      var p = uv - flameBase;
      p.x *= aspect;
      
      // Flip so flame goes UP from base
      p.y = -p.y;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Candle Flame Shape
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Flame sways gently
      let sway = sin(t * 3.0) * 0.015 + sin(t * 7.3) * 0.008;
      p.x -= sway * p.y * 2.0;
      
      // Flame height and width
      let flameHeight = 0.25;
      let flameWidth = 0.035;
      
      // Tear-drop shape for flame
      let normalizedY = clamp(p.y / flameHeight, 0.0, 1.0);
      
      // Width varies: narrow at top, widest near bottom, then tapers at base
      let widthProfile = sin(normalizedY * 3.14159) * (1.0 - normalizedY * 0.3);
      let currentWidth = flameWidth * (0.3 + widthProfile * 0.7);
      
      // Horizontal distance from center
      let xDist = abs(p.x) / currentWidth;
      
      // Vertical flame boundary
      let inFlameY = step(0.0, p.y) * step(p.y, flameHeight);
      
      // Flame intensity based on shape
      var flame = (1.0 - xDist) * inFlameY;
      flame = max(0.0, flame);
      flame = pow(flame, 0.6);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Flickering and Turbulence
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Turbulent edges
      let turbFreq = 15.0;
      let turb = fbm(vec2<f32>(p.x * turbFreq, p.y * turbFreq - t * 8.0), 4);
      flame *= 0.7 + turb * 0.5;
      
      // Inner flame has less turbulence
      let innerFlame = pow(max(0.0, 1.0 - xDist * 1.5), 2.0) * inFlameY;
      
      // Wispy top
      let wispY = (p.y - flameHeight * 0.7) / (flameHeight * 0.3);
      if (wispY > 0.0) {
        let wisp = fbm(vec2<f32>(p.x * 30.0, -t * 12.0), 3);
        flame *= max(0.0, 1.0 - wispY + wisp * 0.5);
      }
      
      // Overall flicker
      let flicker = 0.85 + 0.15 * sin(t * 15.0) * sin(t * 23.0);
      flame *= flicker;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Candle Flame Colors (Blackbody)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      var color = vec3<f32>(0.0);
      
      // Temperature increases toward center and base
      let temp = flame * (0.5 + innerFlame * 0.5) * (1.0 - normalizedY * 0.3);
      
      // Dark red base
      color += vec3<f32>(0.4, 0.02, 0.0) * pow(flame, 0.5) * 0.5;
      
      // Orange outer
      color += vec3<f32>(1.0, 0.35, 0.0) * pow(flame, 0.8) * 1.2;
      
      // Yellow middle
      color += vec3<f32>(1.0, 0.7, 0.15) * pow(flame, 1.2) * 1.5;
      
      // White-blue core (hottest)
      let core = pow(innerFlame, 2.0) * (1.0 - normalizedY);
      color += vec3<f32>(0.9, 0.95, 1.0) * core * 2.0;
      
      // Blue base (like real candle)
      let blueBase = max(0.0, 1.0 - normalizedY * 3.0) * innerFlame;
      color = mix(color, vec3<f32>(0.3, 0.5, 1.0), blueBase * 0.4);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Glowing Base (wick/ember)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let emberDist = length(p * vec2<f32>(1.0, 3.0));
      let ember = exp(-emberDist * 40.0) * 0.8;
      color += vec3<f32>(1.0, 0.4, 0.1) * ember;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Glow around flame
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let glowDist = length(p * vec2<f32>(1.0, 0.5));
      let glow = exp(-glowDist * 8.0) * 0.3;
      color += vec3<f32>(1.0, 0.3, 0.05) * glow;
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Background
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      let bg = vec3<f32>(0.01, 0.01, 0.02);
      
      // Ambient light from flame
      let ambient = exp(-length(uv - vec2<f32>(flameBase.x, 1.0 - flameBase.y)) * 3.0);
      var finalColor = bg + vec3<f32>(0.15, 0.05, 0.02) * ambient;
      
      // Add flame
      finalColor += color;
      
      // Tone mapping
      finalColor = finalColor / (finalColor + 0.8);
      finalColor = pow(finalColor, vec3<f32>(0.9));
      
      // Vignette
      let vignette = 1.0 - length(uv - 0.5) * 0.4;
      finalColor *= vignette;
      
      return vec4<f32>(finalColor, 1.0);
    }
  `,
  { canvas: document.getElementById('c') }
);

// FPS Counter
(function() {
  const fpsDiv = document.createElement('div');
  fpsDiv.style.cssText = 'position:fixed;bottom:10px;left:10px;color:white;font:14px monospace;background:rgba(0,0,0,0.6);padding:6px 12px;border-radius:4px;z-index:10000';
  document.body.appendChild(fpsDiv);
  let frames = 0, lastTime = performance.now();
  function updateFPS() {
    frames++;
    const now = performance.now();
    if (now - lastTime >= 500) {
      fpsDiv.textContent = Math.round(frames * 1000 / (now - lastTime)) + ' fps';
      frames = 0; lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();

console.log('%c ğŸ”¥ WebGPU Candle Flame ', 'background: linear-gradient(90deg, #ff4400, #ff8800); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Move mouse to position the flame!');
</script>
<script>
// Hide home-link if in iframe - run immediately and on load
function hideIfIframe() {
  if (window.self !== window.top) {
    const link = document.querySelector('.home-link');
    if (link) {
      link.style.display = 'none';
    }
  }
}
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hideIfIframe);
} else {
  hideIfIframe();
}
</script>
<a href="index.html" class="home-link">â† Back to Index</a>
</body>
</html>
