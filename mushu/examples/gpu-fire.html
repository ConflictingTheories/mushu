<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mushu â€” WebGPU Fire Demo</title>
  <style>body{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>
<canvas id="c" style="position:fixed;inset:0;width:100%;height:100%"></canvas>
<script type="module">
import { gpu } from '../src/gpu/yoGPU.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WebGPU Fire Simulation with Compute Shaders
// High-performance GPU-accelerated fire physics
// Hold & drag mouse to ignite flames!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

gpu(
  // Compute shader - Fire physics (defines compute(C, uv) function)
  /* wgsl */`
    fn hash(p: vec2<f32>) -> f32 {
      return fract(sin(dot(p, vec2<f32>(127.1, 311.7))) * 43758.5453);
    }
    
    fn noise(p: vec2<f32>) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let s = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i), hash(i + vec2<f32>(1.0, 0.0)), s.x),
        mix(hash(i + vec2<f32>(0.0, 1.0)), hash(i + vec2<f32>(1.0, 1.0)), s.x),
        s.y
      );
    }

    fn compute(C: vec2<i32>, uv: vec2<f32>) {
      var data = sample(C);
      var fuel = data.r;
      var heat = data.g;
      var smoke = data.b;
      
      // In texture space: high Y = bottom of screen visually
      // So heat rising means we sample from higher Y (visual bottom)
      let up = sample(C + vec2<i32>(0, -1));      // visual up
      let down = sample(C + vec2<i32>(0, 1));     // visual down  
      let left = sample(C + vec2<i32>(-1, 0));
      let right = sample(C + vec2<i32>(1, 0));
      
      // Heat diffusion
      let diffusion = 0.12;
      heat += diffusion * (up.g + down.g + left.g + right.g - 4.0 * heat);
      
      // Buoyancy - heat from below (visual) rises
      let buoyancy = 0.2 + heat * 0.08;
      heat = mix(heat, down.g, buoyancy);
      
      // Turbulent lateral movement
      let turb = noise(vec2<f32>(uv.x * 100.0, u.time * 5.0)) * 0.15;
      heat = mix(heat, mix(left.g, right.g, 0.5), turb);
      
      // Fuel behavior
      fuel += 0.04 * (up.r + down.r + left.r + right.r - 4.0 * fuel);
      fuel = mix(fuel, down.r, 0.08);
      
      // Decay
      fuel *= 0.985;
      heat *= 0.98;
      smoke *= 0.995;
      
      // Mouse ignition (mouse Y is already 1-normalized, matching visual)
      let mouse = vec2<f32>(u.mouseX, u.mouseY);
      let mouseUV = vec2<f32>(uv.x, 1.0 - uv.y);  // flip uv to match mouse
      let d = length(mouseUV - mouse);
      
      if (u.mouseDown > 0.5 && d < 0.1) {
        let intensity = pow(1.0 - d / 0.1, 2.0) * 12.0;
        fuel += intensity;
        heat += intensity * 2.0;
      }
      
      // Fire source at bottom (high Y in texture = bottom visually)
      if (uv.y > 0.9) {
        let edge = (uv.y - 0.9) / 0.1;
        let p1 = sin(uv.x * 25.0 + u.time * 4.0) * 0.5 + 0.5;
        let p2 = sin(uv.x * 8.0 - u.time * 2.0) * 0.5 + 0.5;
        let p3 = noise(vec2<f32>(uv.x * 50.0, u.time * 10.0));
        let pattern = p1 * p2 * (0.5 + p3 * 0.5);
        
        if (pattern > 0.25) {
          let intensity = pattern * edge * 2.0;
          fuel += intensity * 1.2;
          heat += intensity * 2.5;
        }
      }
      
      // Combustion
      if (heat > 0.3 && fuel > 0.01) {
        let burn = min(fuel, (heat - 0.3) * 0.6);
        heat += burn * 1.0;
        fuel -= burn;
        smoke += burn * 0.5;
      }
      
      // Smoke rises
      smoke = mix(smoke, down.b, 0.1);
      
      textureStore(dst, C, vec4<f32>(
        clamp(fuel, 0.0, 25.0),
        clamp(heat, 0.0, 25.0),
        clamp(smoke, 0.0, 15.0),
        1.0
      ));
    }
  `,
  
  // Render shader - Fire coloring (defines render(data, uv) function)
  /* wgsl */`
    fn render(data: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {
      let fuel = data.r;
      let heat = data.g;
      let smoke = data.b;
      
      var col = vec3<f32>(0.0);
      
      // Blackbody-inspired color ramp
      col += vec3<f32>(1.0, 1.0, 0.95) * pow(heat, 4.0) * 4.0;   // White core
      col += vec3<f32>(1.0, 0.9, 0.6) * pow(heat, 3.0) * 2.5;    // Bright yellow
      col += vec3<f32>(1.0, 0.6, 0.15) * pow(heat, 2.0) * 2.0;   // Orange
      col += vec3<f32>(1.0, 0.3, 0.0) * pow(heat, 1.3) * 1.5;    // Red-orange
      col += vec3<f32>(0.7, 0.1, 0.0) * pow(heat, 0.7) * 0.8;    // Deep red
      
      // Glowing embers
      let embers = fuel * (1.0 - heat * 0.1);
      col += vec3<f32>(1.0, 0.4, 0.1) * embers * 0.4;
      
      // Smoke overlay
      let smokeCol = vec3<f32>(0.02, 0.02, 0.025);
      let smokeAlpha = 1.0 - exp(-smoke * 0.25);
      col = mix(col, smokeCol, smokeAlpha * 0.85);
      
      // Tone mapping
      col = 1.0 - exp(-col * 0.65);
      col = pow(col, vec3<f32>(0.92));
      
      return vec4<f32>(col, 1.0);
    }
  `,
  { canvas: document.getElementById('c'), scale: 0.5 }
);

console.log('%c ğŸ”¥ mushu WebGPU Fire Ready ', 'background: linear-gradient(90deg, #ff4500, #ff8c00); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold;');
console.log('Hold & drag mouse to ignite flames!');
</script>
</body>
</html>
